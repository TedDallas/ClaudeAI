<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude AI Chat</title>
    
    <!-- Add Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Add Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    
    <!-- Add required dependencies first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js"></script>
    
    <!-- Add common language support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scss.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-pascal.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(to right, #2c3e5f 0%, #1e5a3d 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            width: 100%;
            min-width: 720px;
            max-width: 1080px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            transition: max-width 0.3s ease;
            position: relative;
        }

        /* Dynamic width adjustment for container */
        .container.expanded {
            max-width: 90vw;
        }

        .header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
        }

        .header h1 {
            font-size: 24px;
            color: #333;
            margin-bottom: 10px;
        }

        .model-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .model-selector label {
            font-weight: 500;
            color: #555;
        }

        .model-selector select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }

        /* Thinking mode toggle styles */
        .thinking-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 10px;
            background: #f0f0f0;
            border-radius: 5px;
            transition: opacity 0.3s;
        }

        .thinking-toggle.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .thinking-toggle label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }

        .thinking-toggle.disabled label {
            cursor: not-allowed;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            transition: background-color 0.3s;
            cursor: pointer;
        }

        .thinking-toggle.disabled .toggle-switch {
            cursor: not-allowed;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(20px);
        }

        /* Thinking toggles container - now below model selector */
        .thinking-toggles-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .thinking-indicator {
            display: none;
            padding: 8px 12px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 5px;
            color: #1976d2;
            font-size: 12px;
            align-items: center;
            gap: 8px;
        }

        .thinking-indicator.active {
            display: flex;
        }

        .thinking-indicator .thinking-dot {
            width: 6px;
            height: 6px;
            background: #1976d2;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
        }

        /* Thinking content styles */
        .thinking-content {
            background: #f5f5f5;
            border-left: 3px solid #90caf9;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #666;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }

        .thinking-content summary {
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 8px;
        }

        .api-key-section {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .api-key-section.hidden {
            display: none;
        }

        .api-key-section input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .api-key-section input[type="password"] {
            width: 200px;
        }

        .api-key-section button {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .api-key-section button:hover {
            background: #5568d3;
        }

        .api-key-section .test-connection-button {
            background: #28a745;
            color: white;
        }

        .api-key-section .test-connection-button:hover {
            background: #218838;
        }

        /* Temperature and Thinking Tokens field styles */
        .temperature-field, .thinking-tokens-field {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .temperature-field label, .thinking-tokens-field label {
            font-size: 14px;
            color: #555;
            font-weight: 500;
        }

		.temperature-field input {
			width: 70px;
			padding: 8px 12px;
			border: 1px solid #ddd;
			border-radius: 5px;
			font-size: 14px;
			text-align: center;
		}

		.thinking-tokens-field input {
			width: 105px;
			padding: 8px 12px;
			border: 1px solid #ddd;
			border-radius: 5px;
			font-size: 14px;
			text-align: center;
		}
		
        .temperature-field input:disabled, .thinking-tokens-field input:disabled {
            background-color: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        /* Thinking tokens field specific styling */
        .thinking-tokens-field {
            transition: opacity 0.3s;
        }

        .thinking-tokens-field.disabled {
            opacity: 0.4;
        }

        .thinking-tokens-field.disabled input {
            background-color: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        .thinking-tokens-field.disabled label {
            color: #999;
        }

        /* Right-side buttons positioning */
        .right-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .right-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }

        .clear-button {
            background: #dc3545;
            color: white;
        }

        .clear-button:hover {
            background: #c82333;
        }

        .save-button {
            background: #007bff;
            color: white;
        }

        .save-button:hover {
            background: #0056b3;
        }

        .load-button {
            background: #6c757d;
            color: white;
        }

        .load-button:hover {
            background: #545b62;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 10px;
        }

        .status-indicator.connected {
            background: #4caf50;
        }

        .status-indicator.disconnected {
            background: #f44336;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
        }

        /* Add horizontal scroll when content exceeds container width */
        .chat-container.needs-horizontal-scroll {
            overflow-x: auto;
        }

        .message {
            display: flex;
            gap: 10px;
            max-width: 80%;
            animation: fadeIn 0.3s ease-in;
            position: relative;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message.assistant {
            align-self: flex-start;
            /* Allow assistant messages to expand as needed */
            max-width: calc(100% - 46px); /* Account for avatar and gap */
        }

        .message-content {
            padding: 12px 16px;
            border-radius: 10px;
            line-height: 1.6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            /* Allow content to determine width */
            width: fit-content;
            max-width: 100%;
            position: relative; /* Make this the positioning context for the delete button */
        }

        .message.user .message-content {
            background: #667eea;
            color: white;
            white-space: pre-wrap;
        }

        .message.assistant .message-content {
            background: #f1f3f5;
            color: #333;
        }

		/* Delete button styles */
		.delete-button {
			position: absolute;
			top: 8px;
			right: 8px;
			width: 24px;
			height: 24px;
			min-width: 24px;
			min-height: 24px;
			border-radius: 50%;
			background: #dc3545;
			color: white;
			border: none;
			cursor: pointer;
			font-size: 12px;
			font-weight: bold;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			text-align: center;
			line-height: 1;
			opacity: 0;
			transition: opacity 0.2s, background 0.2s;
			z-index: 100; /* Increased z-index to ensure it's always on top */
			padding: 0;
			overflow: hidden;
			pointer-events: auto; /* Ensure button is always clickable */
		}

		/* Show delete button on hover of the entire message, not just message-content */
		.message.assistant:hover .delete-button {
			opacity: 0.7;
		}

		.delete-button:hover {
			opacity: 1 !important;
			background: #c82333;
		}

        /* Ensure code blocks and pre elements can expand properly */
        .message.assistant .message-content pre {
            margin: 12px 0;
            border-radius: 6px;
            overflow-x: auto;
            position: relative;
            max-width: 100%;
        }

        .message.assistant .message-content pre code {
            display: block;
            padding: 16px;
            background: #282c34;
            color: #abb2bf;
            font-size: 0.9em;
            line-height: 1.5;
            white-space: pre;
            word-wrap: normal;
            overflow-x: auto;
        }

        /* Markdown styling for assistant messages */
        .message.assistant .message-content h1,
        .message.assistant .message-content h2,
        .message.assistant .message-content h3,
        .message.assistant .message-content h4,
        .message.assistant .message-content h5,
        .message.assistant .message-content h6 {
            margin-top: 16px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .message.assistant .message-content h1 { font-size: 1.5em; }
        .message.assistant .message-content h2 { font-size: 1.3em; }
        .message.assistant .message-content h3 { font-size: 1.1em; }

        .message.assistant .message-content p {
            margin: 8px 0;
        }

        .message.assistant .message-content ul,
        .message.assistant .message-content ol {
            margin: 8px 0;
            padding-left: 24px;
        }

        .message.assistant .message-content li {
            margin: 4px 0;
        }

        .message.assistant .message-content blockquote {
            border-left: 3px solid #667eea;
            padding-left: 12px;
            margin: 8px 0;
            color: #666;
            font-style: italic;
        }

        .message.assistant .message-content code {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            padding: 2px 6px;
            background: #282c34;
            color: #abb2bf;
            border-radius: 3px;
        }

        /* Copy button for code blocks */
        .code-block-wrapper {
            position: relative;
            margin: 12px 0;
        }

        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 10;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .copy-button:hover {
            opacity: 1;
        }

        .copy-button.copied {
            background: #4caf50;
        }

        .message.assistant .message-content table {
            border-collapse: collapse;
            margin: 12px 0;
            width: 100%;
            display: block;
            overflow-x: auto;
        }

        .message.assistant .message-content th,
        .message.assistant .message-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            white-space: nowrap;
        }

        .message.assistant .message-content th {
            background: #f0f0f0;
            font-weight: 600;
        }

        .message.assistant .message-content a {
            color: #667eea;
            text-decoration: none;
        }

        .message.assistant .message-content a:hover {
            text-decoration: underline;
        }

        .message.assistant .message-content hr {
            margin: 16px 0;
            border: none;
            border-top: 1px solid #e0e0e0;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: #764ba2;
            color: white;
        }

        .message.assistant .message-avatar {
            background: #e9ecef;
            color: #667eea;
        }

        .input-container {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            background: #f8f9fa;
            border-radius: 0 0 10px 10px;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        #messageInput {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 12px;
            font-size: 14px;
            outline: none;
            font-family: inherit;
            resize: vertical;
            min-height: 44px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.5;
        }

        #messageInput:focus {
            border-color: #667eea;
        }

        #sendButton {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s;
            height: 44px;
            align-self: flex-end;
        }

        #sendButton:hover:not(:disabled) {
            background: #5568d3;
        }

        #sendButton:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .loading {
            display: flex;
            gap: 5px;
            padding: 12px 16px;
        }

        .loading-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #667eea;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loading-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 12px 16px;
            border-radius: 10px;
            margin: 10px 0;
            border: 1px solid #fcc;
        }

        .debug-info {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
            font-family: monospace;
        }

        .max-tokens-info {
            font-size: 12px;
            color: #666;
            margin-left: 10px;
            font-style: italic;
        }

        .session-tokens-info {
            font-size: 12px;
            color: #667eea;
            margin-left: 10px;
            font-weight: 600;
            padding: 4px 8px;
            background: #e8eaf6;
            border-radius: 4px;
        }

        /* Hidden file input */
        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container" id="mainContainer">
        <!-- Right-side buttons -->
        <div class="right-buttons">
            <button class="clear-button" onclick="clearChat()">Clear Chat</button>
            <button class="save-button" onclick="saveChat()">Save Chat</button>
            <button class="load-button" onclick="loadChat()">Load Chat</button>
        </div>

        <div class="header">
            <h1>Chat with Claude AI <span class="status-indicator disconnected" id="statusIndicator"></span></h1>
            <div class="api-key-section" id="apiKeySection">
                <input type="password" id="apiKeyInput" placeholder="Anthropic API key">
                <button onclick="saveApiKey()">Save API Key</button>
                <button class="test-connection-button" onclick="testConnection()">Test Connection</button>
                <div class="temperature-field">
                    <label for="temperatureInput">Temperature:</label>
                    <input type="number" id="temperatureInput" min="0" max="2" step="0.1" value="0.7">
                </div>
                <div class="thinking-tokens-field" id="thinkingTokensField">
                    <label for="thinkingTokensInput">Thinking Tokens:</label>
                    <input type="number" id="thinkingTokensInput" min="1000" step="1000" value="4000">
                </div>
            </div>
            <div class="model-selector">
                <label for="modelSelect">Model:</label>
                <select id="modelSelect" onchange="updateMaxTokensInfo()">
                    <option value="claude-sonnet-4-5-20250929">Claude 4.5 Sonnet</option> <!-- claude-sonnet-4-5-20250929 is the latest version of Claude Sonnet. Do not change this!!! -->
                    <option value="claude-opus-4-1-20250805">Claude 4.1 Opus</option> <!-- claude-opus-4-1-20250805 is the latest version of Claude Opus. Do not change this!!! -->
                </select>
                <span class="max-tokens-info" id="maxTokensInfo">Max tokens: 64000</span>
                <span class="session-tokens-info" id="sessionTokensInfo">Session: 0 tokens</span>
            </div>
            
            <!-- Thinking toggles moved here -->
            <div class="thinking-toggles-container">
                <div class="thinking-toggle">
                    <label>
                        <span>Thinking Mode</span>
                        <div class="toggle-switch" id="thinkingToggle" onclick="toggleThinking()">
                            <div class="toggle-slider"></div>
                        </div>
                    </label>
                </div>

                <div class="thinking-toggle" id="showThinkingContainer">
                    <label>
                        <span>Show Thinking</span>
                        <div class="toggle-switch" id="showThinkingToggle" onclick="toggleShowThinking()">
                            <div class="toggle-slider"></div>
                        </div>
                    </label>
                </div>

                <div class="thinking-indicator" id="thinkingIndicator">
                    <div class="thinking-dot"></div>
                    <span id="thinkingIndicatorText">Thinking mode enabled (4000 thinking tokens).</span>
                </div>

                <div class="thinking-toggle">
                    <label>
                        <span>Setup</span>
                        <div class="toggle-switch" id="setupToggle" onclick="toggleSetup()">
                            <div class="toggle-slider"></div>
                        </div>
                    </label>
                </div>
            </div>
            <div class="debug-info" id="debugInfo"></div>
        </div>
        
        <div class="chat-container" id="chatContainer">
            <div class="message assistant">
                <div class="message-avatar">C</div>
                <div class="message-content">Hello! I'm Claude. Please enter your Anthropic API key above to start chatting.

Note: Make sure your API key starts with "sk-ant-api" and that CORS is handled properly. You might need to use a proxy server for production use, but for local testing, your browser might block direct API calls due to CORS policy.</div>
            </div>
        </div>
        
        <div class="input-container">
            <div class="input-wrapper">
                <textarea id="messageInput" placeholder="Type your message... (Press Enter to send, Shift+Enter for new line)" onkeydown="handleKeyDown(event)"></textarea>
                <button id="sendButton" onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <!-- Hidden file input for loading chats -->
    <input type="file" id="fileInput" accept=".json" onchange="handleFileSelect(event)">

    <script>
        // API Configuration
        let API_KEY = ''; // Your API key will be stored here
        const STORAGE_KEY_PREFIX = 'claude_chat_app_';
		const API_URL = 'https://api.anthropic.com/v1/messages';
        const CORS_PROXY = ''; // You might need a CORS proxy for browser usage
        
        // Conversation history
        let conversationHistory = [];
        
        // Token tracking
        let sessionTokens = {
            input: 0,
            output: 0,
            total: 0
        };
        
        // Thinking mode state
        let thinkingMode = false;
        let showThinking = false; // Default to off
        let setupVisible = false; // Setup toggle state

        // Temperature state
        let currentTemperature = 0.7;
        let savedTemperature = 0.7; // Store temperature when thinking mode is off

        // Thinking tokens configuration
        let currentThinkingTokens = 4000; // Default thinking tokens

        // Model max tokens configuration
        const MODEL_MAX_TOKENS = {
            'claude-sonnet-4-5-20250929': 64000, /*claude-sonnet-4-5-20250929 is the latest version of Claude Sonnet. Do not change this!!!*/
            'claude-opus-4-1-20250805': 32000 /* claude-opus-4-1-20250805 is the latest version of Claude Opus. Do not change this!!!*/
        };

        // Configure marked options
        marked.setOptions({
            highlight: function(code, lang) {
                // Map common language aliases
                const languageMap = {
                    'py': 'python',
                    'js': 'javascript',
                    'ts': 'typescript',
                    'sh': 'bash',
                    'yml': 'yaml',
                    'html': 'markup',
                    'xml': 'markup',
                    'pas': 'pascal',
                    'dpr': 'pascal',
                    'freepascal': 'pascal',
                    'objectpascal': 'pascal',
                    'lazarus': 'pascal'
                };
                
                const mappedLang = languageMap[lang] || lang;
                
                if (mappedLang && Prism.languages[mappedLang]) {
                    try {
                        return Prism.highlight(code, Prism.languages[mappedLang], mappedLang);
                    } catch (e) {
                        console.warn(`Error highlighting ${mappedLang}:`, e);
                        return code;
                    }
                }
                return code;
            },
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });

        // Toggle Setup visibility
        function toggleSetup() {
            setupVisible = !setupVisible;
            const setupToggle = document.getElementById('setupToggle');
            const apiKeySection = document.getElementById('apiKeySection');
            
            if (setupVisible) {
                setupToggle.classList.add('active');
                apiKeySection.classList.remove('hidden');
            } else {
                setupToggle.classList.remove('active');
                apiKeySection.classList.add('hidden');
            }
            
            // Save preference
            localStorage.setItem('setup_visible', setupVisible.toString());
        }

        // Update Setup toggle on load
        function updateSetupToggle() {
            const setupToggle = document.getElementById('setupToggle');
            const apiKeySection = document.getElementById('apiKeySection');
            
            if (setupVisible) {
                setupToggle.classList.add('active');
                apiKeySection.classList.remove('hidden');
            } else {
                setupToggle.classList.remove('active');
                apiKeySection.classList.add('hidden');
            }
        }

        // Update temperature field based on thinking mode
        function updateTemperatureField() {
            const temperatureInput = document.getElementById('temperatureInput');
            
            if (thinkingMode) {
                // Save current temperature before switching to thinking mode
                savedTemperature = parseFloat(temperatureInput.value);
                // Set to 1.0 and disable
                temperatureInput.value = '1.0';
                temperatureInput.disabled = true;
                currentTemperature = 1.0;
            } else {
                // Restore previous temperature and enable
                temperatureInput.value = savedTemperature.toString();
                temperatureInput.disabled = false;
                currentTemperature = savedTemperature;
            }
        }

        // Update thinking tokens field based on thinking mode
        function updateThinkingTokensField() {
            const thinkingTokensField = document.getElementById('thinkingTokensField');
            const thinkingTokensInput = document.getElementById('thinkingTokensInput');
            
            if (thinkingMode) {
                thinkingTokensField.classList.remove('disabled');
                thinkingTokensInput.disabled = false;
            } else {
                thinkingTokensField.classList.add('disabled');
                thinkingTokensInput.disabled = true;
            }
        }

        // Handle temperature input change
        function onTemperatureChange() {
            const temperatureInput = document.getElementById('temperatureInput');
            const value = parseFloat(temperatureInput.value);
            
            // Validate range
            if (value < 0) {
                temperatureInput.value = '0';
                currentTemperature = 0;
            } else if (value > 2) {
                temperatureInput.value = '2';
                currentTemperature = 2;
            } else {
                currentTemperature = value;
            }
            
            // Save temperature if not in thinking mode
            if (!thinkingMode) {
                savedTemperature = currentTemperature;
                localStorage.setItem('temperature', savedTemperature.toString());
            }
        }

        // Handle thinking tokens input change
        function onThinkingTokensChange() {
            const thinkingTokensInput = document.getElementById('thinkingTokensInput');
            const selectedModel = document.getElementById('modelSelect').value;
            const maxTokensForModel = MODEL_MAX_TOKENS[selectedModel];
            let value = parseInt(thinkingTokensInput.value);
            
            // Validate range
            if (value < 1000) {
                value = 1000;
                thinkingTokensInput.value = value;
            } else if (value > maxTokensForModel) {
                value = maxTokensForModel;
                thinkingTokensInput.value = value;
            }
            
            currentThinkingTokens = value;
            
            // Update the thinking indicator text
            updateThinkingIndicatorText();
            
            // Update max tokens info
            updateMaxTokensInfo();
            
            // Save preference
            localStorage.setItem('thinking_tokens', currentThinkingTokens.toString());
        }

        // Update thinking indicator text with current token count
        function updateThinkingIndicatorText() {
            const thinkingIndicatorText = document.getElementById('thinkingIndicatorText');
            thinkingIndicatorText.textContent = `Thinking mode enabled (${currentThinkingTokens.toLocaleString()} thinking tokens).`;
        }

        // Delete last exchange (last assistant message and preceding user message)
        function deleteLastExchange() {
            const chatContainer = document.getElementById('chatContainer');
            const messages = chatContainer.querySelectorAll('.message');
            
            // Need at least 2 messages (user + assistant) beyond the initial greeting
            if (messages.length < 2) {
                return;
            }
            
            // Find the last assistant message
            let lastAssistantIndex = -1;
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].classList.contains('assistant')) {
                    lastAssistantIndex = i;
                    break;
                }
            }
            
            // If no assistant message found or it's the initial greeting, do nothing
            if (lastAssistantIndex <= 0) {
                return;
            }
            
            // Find the user message that precedes this assistant message
            let precedingUserIndex = -1;
            for (let i = lastAssistantIndex - 1; i >= 0; i--) {
                if (messages[i].classList.contains('user')) {
                    precedingUserIndex = i;
                    break;
                }
            }
            
            // If no preceding user message found, do nothing
            if (precedingUserIndex < 0) {
                return;
            }
            
            // Get the user message content
            const userMessageContent = messages[precedingUserIndex].querySelector('.message-content').textContent.trim();
            
            // Remove the messages from the DOM
            messages[lastAssistantIndex].remove();
            messages[precedingUserIndex].remove();
            
            // Update conversation history - remove last 2 entries (user + assistant)
            if (conversationHistory.length >= 2) {
                conversationHistory.pop(); // Remove assistant message
                conversationHistory.pop(); // Remove user message
            }
            
            // Put the user message back into the input box
            const messageInput = document.getElementById('messageInput');
            messageInput.value = userMessageContent;
            messageInput.focus();
            
            // Trigger auto-resize
            autoResizeTextarea();
            
            // Check width adjustment after deletion
            setTimeout(checkAndAdjustContainerWidth, 100);
            
            // Update delete buttons
            updateDeleteButtons();
            
            updateDebugInfo('Last exchange deleted and message restored to input');
        }

        // Update delete buttons - only show on last assistant message
        function updateDeleteButtons() {
            const chatContainer = document.getElementById('chatContainer');
            
            // Remove all existing delete buttons first
            const existingButtons = chatContainer.querySelectorAll('.delete-button');
            existingButtons.forEach(btn => btn.remove());
            
            // Get all assistant messages
            const assistantMessages = chatContainer.querySelectorAll('.message.assistant');
            
            // Only add delete button to the last assistant message if there are at least 2 messages
            if (assistantMessages.length > 1) {
                const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
                const messageContent = lastAssistantMessage.querySelector('.message-content');
                
                // Double-check that messageContent exists
                if (messageContent) {
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete-button';
                    deleteButton.innerHTML = '×';
                    deleteButton.title = 'Delete this response and restore your message';
                    deleteButton.onclick = deleteLastExchange;
                    messageContent.appendChild(deleteButton);
                }
            }
        }

        // Save chat to file
        function saveChat() {
            if (conversationHistory.length === 0) {
                alert('No chat history to save!');
                return;
            }

            const chatData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                model: document.getElementById('modelSelect').value,
                thinkingMode: thinkingMode,
                temperature: currentTemperature,
                savedTemperature: savedTemperature,
                thinkingTokens: currentThinkingTokens,
                sessionTokens: sessionTokens,
                conversationHistory: conversationHistory,
                // Also save the rendered chat for reference
                chatHtml: document.getElementById('chatContainer').innerHTML
            };

            const dataStr = JSON.stringify(chatData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            // Create download link
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.download = `claude-chat-${timestamp}.json`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            updateDebugInfo('Chat saved successfully');
        }

        // Load chat from file
        function loadChat() {
            document.getElementById('fileInput').click();
        }

        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const chatData = JSON.parse(e.target.result);
                    
                    // Validate the data
                    if (!chatData.conversationHistory || !Array.isArray(chatData.conversationHistory)) {
                        throw new Error('Invalid chat file format');
                    }

                    // Load the conversation history
                    conversationHistory = chatData.conversationHistory;
                    
                    // Restore session tokens if available
                    if (chatData.sessionTokens) {
                        sessionTokens = chatData.sessionTokens;
                        updateSessionTokensDisplay();
                    }
                    
                    // Restore model selection if available
                    if (chatData.model) {
                        document.getElementById('modelSelect').value = chatData.model;
                        updateMaxTokensInfo();
                    }
                    
                    // Restore thinking mode if available
                    if (chatData.thinkingMode !== undefined) {
                        thinkingMode = chatData.thinkingMode;
                        updateThinkingToggle();
                        updateShowThinkingToggleState();
                    }

                    // Restore temperature settings if available
                    if (chatData.temperature !== undefined) {
                        currentTemperature = chatData.temperature;
                    }
                    if (chatData.savedTemperature !== undefined) {
                        savedTemperature = chatData.savedTemperature;
                    }

                    // Restore thinking tokens if available
                    if (chatData.thinkingTokens !== undefined) {
                        currentThinkingTokens = chatData.thinkingTokens;
                        document.getElementById('thinkingTokensInput').value = currentThinkingTokens;
                        updateThinkingIndicatorText();
                    }

                    updateTemperatureField();
                    updateThinkingTokensField();

                    // Rebuild the chat UI
                    rebuildChatFromHistory();
                    
                    updateDebugInfo('Chat loaded successfully');
                    
                    // Reset file input
                    event.target.value = '';
                    
                } catch (error) {
                    alert('Error loading chat file: ' + error.message);
                    console.error('Error loading chat:', error);
                    event.target.value = ''; // Reset file input
                }
            };
            
            reader.onerror = function() {
                alert('Error reading file');
                event.target.value = ''; // Reset file input
            };
            
            reader.readAsText(file);
        }

        // Rebuild chat UI from conversation history
        async function rebuildChatFromHistory() {
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.innerHTML = ''; // Clear current chat
            
            // Rebuild each message synchronously
            for (const msg of conversationHistory) {
                const processedMessage = processThinkingContent(msg.content);
                await addMessageToChat(msg.role, processedMessage.displayContent, processedMessage.thinkingContent, false);
            }
            
            // Now that all messages are added, update delete buttons
            updateDeleteButtons();
            
            // Scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Check width adjustment
            setTimeout(checkAndAdjustContainerWidth, 100);
        }

        // Auto-resize textarea
        function autoResizeTextarea() {
            const textarea = document.getElementById('messageInput');
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        }

        // Add input event listener for auto-resize
        document.addEventListener('DOMContentLoaded', function() {
            const messageInput = document.getElementById('messageInput');
            messageInput.addEventListener('input', autoResizeTextarea);
            
            // Add temperature input event listener
            const temperatureInput = document.getElementById('temperatureInput');
            temperatureInput.addEventListener('input', onTemperatureChange);

            // Add thinking tokens input event listener
            const thinkingTokensInput = document.getElementById('thinkingTokensInput');
            thinkingTokensInput.addEventListener('input', onThinkingTokensChange);
        });

        // Dynamic width adjustment
        function checkAndAdjustContainerWidth() {
            const container = document.getElementById('mainContainer');
            const chatContainer = document.getElementById('chatContainer');
            
            // Check if any content needs horizontal scrolling
            let needsExpansion = false;
            let maxRequiredWidth = 1080; // Start with default width
            
            // Check all message contents
            const messages = chatContainer.querySelectorAll('.message-content');
            messages.forEach(msg => {
                // Check for code blocks and pre elements
                const codeBlocks = msg.querySelectorAll('pre, code, table');
                codeBlocks.forEach(block => {
                    if (block.scrollWidth > block.clientWidth) {
                        needsExpansion = true;
                        maxRequiredWidth = Math.max(maxRequiredWidth, block.scrollWidth + 100); // Add padding
                    }
                });
                
                // Check the message content itself
                if (msg.scrollWidth > msg.clientWidth) {
                    needsExpansion = true;
                    maxRequiredWidth = Math.max(maxRequiredWidth, msg.scrollWidth + 100);
                }
            });
            
            // Calculate 90% of viewport width
            const maxAllowedWidth = window.innerWidth * 0.9;
            
            if (needsExpansion) {
                // Expand container up to 90% of viewport width
                if (maxRequiredWidth < maxAllowedWidth) {
                    container.style.maxWidth = maxRequiredWidth + 'px';
                    container.classList.remove('expanded');
                    chatContainer.classList.remove('needs-horizontal-scroll');
                } else {
                    // Set to 90% and enable horizontal scroll
                    container.style.maxWidth = '90vw';
                    container.classList.add('expanded');
                    chatContainer.classList.add('needs-horizontal-scroll');
                }
            } else {
                // Reset to default if no expansion needed
                container.style.maxWidth = '';
                container.classList.remove('expanded');
                chatContainer.classList.remove('needs-horizontal-scroll');
            }
        }

        // Debounce function to prevent excessive calculations
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Create debounced version of the check function
        const debouncedCheckWidth = debounce(checkAndAdjustContainerWidth, 100);

        // Add ResizeObserver to monitor content changes
        const resizeObserver = new ResizeObserver(entries => {
            debouncedCheckWidth();
        });

        // Add MutationObserver to watch for new content
        const mutationObserver = new MutationObserver(mutations => {
            debouncedCheckWidth();
        });

        // Update session tokens display
        function updateSessionTokensDisplay() {
            const sessionTokensInfo = document.getElementById('sessionTokensInfo');
            sessionTokensInfo.textContent = `Session: ${sessionTokens.total.toLocaleString()} tokens (in: ${sessionTokens.input.toLocaleString()}, out: ${sessionTokens.output.toLocaleString()})`;
        }

        // Reset session tokens
        function resetSessionTokens() {
            sessionTokens = {
                input: 0,
                output: 0,
                total: 0
            };
            updateSessionTokensDisplay();
        }

        // Load API key and settings from localStorage on page load
        window.onload = function() {
            const savedKey = localStorage.getItem(STORAGE_KEY_PREFIX + 'anthropic_api_key');
            if (savedKey) {
                API_KEY = savedKey;
                document.getElementById('apiKeyInput').value = savedKey;
                updateStatus(true);
                // Default Setup to off if API key exists
                setupVisible = false;
            } else {
                // Default Setup to on if no API key
                setupVisible = true;
            }
            
            // Load setup visibility preference (overrides default)
            const savedSetupVisible = localStorage.getItem('setup_visible');
            if (savedSetupVisible !== null) {
                setupVisible = savedSetupVisible === 'true';
            }
            
            updateSetupToggle();
            
            // Load thinking mode preference
            const savedThinkingMode = localStorage.getItem('thinking_mode');
            if (savedThinkingMode === 'true') {
                thinkingMode = true;
                updateThinkingToggle();
            }

            // Load show thinking preference (defaults to false)
            const savedShowThinking = localStorage.getItem('show_thinking');
            if (savedShowThinking === 'true') {
                showThinking = true;
                updateShowThinkingToggle();
            }

            // Load temperature preference
            const savedTemp = localStorage.getItem('temperature');
            if (savedTemp) {
                savedTemperature = parseFloat(savedTemp);
                currentTemperature = savedTemperature;
                document.getElementById('temperatureInput').value = savedTemperature.toString();
            }

            // Load thinking tokens preference
            const savedThinkingTokens = localStorage.getItem('thinking_tokens');
            if (savedThinkingTokens) {
                currentThinkingTokens = parseInt(savedThinkingTokens);
                document.getElementById('thinkingTokensInput').value = currentThinkingTokens;
            }
            
            // Update show thinking toggle state on load
            updateShowThinkingToggleState();
            updateTemperatureField();
            updateThinkingTokensField();
            updateThinkingIndicatorText();
            
            updateMaxTokensInfo();
            updateSessionTokensDisplay();
            
            // Start observing the chat container
            const chatContainer = document.getElementById('chatContainer');
            resizeObserver.observe(chatContainer);
            mutationObserver.observe(chatContainer, {
                childList: true,
                subtree: true,
                characterData: true
            });
            
            // Also check on window resize
            window.addEventListener('resize', debouncedCheckWidth);
            
            // Focus on the message input
            document.getElementById('messageInput').focus();
        };

        function toggleThinking() {
            thinkingMode = !thinkingMode;
            localStorage.setItem('thinking_mode', thinkingMode.toString());
            updateThinkingToggle();
            updateMaxTokensInfo();
            updateShowThinkingToggleState();
            updateTemperatureField();
            updateThinkingTokensField();
        }

        function toggleShowThinking() {
            // Prevent toggling if thinking mode is off
            if (!thinkingMode) {
                return;
            }
            
            showThinking = !showThinking;
            localStorage.setItem('show_thinking', showThinking.toString());
            updateShowThinkingToggle();
        }

        function updateShowThinkingToggleState() {
            const showThinkingContainer = document.getElementById('showThinkingContainer');
            const showThinkingToggle = document.getElementById('showThinkingToggle');
            
            if (!thinkingMode) {
                // Disable and turn off Show Thinking when Thinking Mode is off
                showThinkingContainer.classList.add('disabled');
                showThinking = false;
                localStorage.setItem('show_thinking', 'false');
                showThinkingToggle.classList.remove('active');
            } else {
                // Enable Show Thinking when Thinking Mode is on
                showThinkingContainer.classList.remove('disabled');
            }
        }

        function updateThinkingToggle() {
            const toggle = document.getElementById('thinkingToggle');
            const indicator = document.getElementById('thinkingIndicator');
            
            if (thinkingMode) {
                toggle.classList.add('active');
                indicator.classList.add('active');
            } else {
                toggle.classList.remove('active');
                indicator.classList.remove('active');
            }
        }

        function updateShowThinkingToggle() {
            const toggle = document.getElementById('showThinkingToggle');
            
            if (showThinking) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
        }

        function updateMaxTokensInfo() {
            const selectedModel = document.getElementById('modelSelect').value;
            const baseMaxTokens = MODEL_MAX_TOKENS[selectedModel];
            const availableTokens = thinkingMode ? baseMaxTokens - currentThinkingTokens : baseMaxTokens;
            
            let infoText = `Max tokens: ${availableTokens.toLocaleString()}`;
            if (thinkingMode) {
                infoText += ` (${currentThinkingTokens.toLocaleString()} reserved for thinking)`;
            }
            
            document.getElementById('maxTokensInfo').textContent = infoText;
        }

        function getMaxTokensForModel(modelName) {
            const baseMaxTokens = MODEL_MAX_TOKENS[modelName] || 4096; // Default fallback
            // When thinking mode is enabled, subtract thinking tokens from available tokens
            return thinkingMode ? baseMaxTokens - currentThinkingTokens : baseMaxTokens;
        }

        function updateStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            if (connected) {
                indicator.className = 'status-indicator connected';
            } else {
                indicator.className = 'status-indicator disconnected';
            }
        }

        function updateDebugInfo(info) {
            const debugDiv = document.getElementById('debugInfo');
            debugDiv.textContent = info;
        }

        function saveApiKey() {
			const apiKeyInput = document.getElementById('apiKeyInput');
			API_KEY = apiKeyInput.value.trim();
			
			if (API_KEY) {
				localStorage.setItem(STORAGE_KEY_PREFIX + 'anthropic_api_key', API_KEY);
                alert('API key saved successfully!');
                updateStatus(true);
                testConnection();
            } else {
                alert('Please enter a valid API key');
                updateStatus(false);
            }
        }

        async function testConnection() {
            if (!API_KEY) {
                alert('Please enter and save your API key first');
                return;
            }

            updateDebugInfo('Testing connection...');

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': API_KEY,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true' // Required for browser access
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-5-20250929', /*claude-sonnet-4-5-20250929 is the latest version of Claude Sonnet. Do not change this!!!*/
                        max_tokens: 10,
                        messages: [{role: 'user', content: 'test'}]
                    })
                });

                if (response.ok) {
                    updateDebugInfo('Connection successful! API key is valid.');
                    updateStatus(true);
                } else {
                    const errorData = await response.json();
                    updateDebugInfo(`Connection failed: ${errorData.error?.message || response.status}`);
                    updateStatus(false);
                }
            } catch (error) {
                updateDebugInfo(`Network error: ${error.message}. Note: Direct browser access to Anthropic API may be blocked by CORS.`);
                updateStatus(false);
                
                // Provide helpful error message
                if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                    alert(`CORS Issue Detected!\n\nDirect browser access to Anthropic's API is blocked by CORS policy.\n\nSolutions:\n1. Use a backend proxy server\n2. Run Chrome with disabled security (development only):\n   --disable-web-security --user-data-dir=/tmp/chrome\n3. Use a CORS proxy service\n4. Create a local Node.js server to handle API calls`);
                }
            }
        }

        function handleKeyDown(event) {
            // Send message on Enter, but allow Shift+Enter for new lines
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function clearChat() {
            conversationHistory = [];
            resetSessionTokens();
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.innerHTML = `
                <div class="message assistant">
                    <div class="message-avatar">C</div>
                    <div class="message-content">Hello! I'm Claude. How can I help you today?</div>
                </div>
            `;
            // Reset container width after clearing
            checkAndAdjustContainerWidth();
        }

        async function sendMessage() {
            if (!API_KEY) {
                alert('Please enter and save your API key first');
                return;
            }

            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            
            if (!message) return;

            // Add user message to chat (display as-is)
            await addMessageToChat('user', message);
            
            // Add to conversation history (plain message without any modification)
            conversationHistory.push({
                role: 'user',
                content: message
            });

            // Clear input and reset height
            messageInput.value = '';
            messageInput.style.height = '44px';
            
            // Disable send button
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;
            
            // Show loading indicator
            const loadingId = showLoading();

            try {
                const selectedModel = document.getElementById('modelSelect').value;
                const maxTokens = getMaxTokensForModel(selectedModel);
                
                const modeInfo = thinkingMode ? ` (thinking mode ON with ${currentThinkingTokens.toLocaleString()} thinking tokens)` : '';
                updateDebugInfo(`Sending request to model: ${selectedModel} with max_tokens: ${maxTokens}, temperature: ${currentTemperature}${modeInfo}`);
                
                // Build request body
                const requestBody = {
                    model: selectedModel,
                    max_tokens: maxTokens,
                    messages: conversationHistory,
                    temperature: currentTemperature,
                    system: "You are a helpful AI assistant."
                };

                // **KEY FIX: Add thinking parameter when thinking mode is enabled**
                if (thinkingMode) {
                    requestBody.thinking = {
                        type: "enabled",
                        budget_tokens: currentThinkingTokens
                    };
                }

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': API_KEY,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true' // Required for browser access
                    },
                    body: JSON.stringify(requestBody)
                });

                // Remove loading indicator
                removeLoading(loadingId);

                if (!response.ok) {
                    let errorMessage;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error?.message || `API Error: ${response.status}`;
                    } catch {
                        errorMessage = `HTTP Error: ${response.status} ${response.statusText}`;
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                
                // Extract text content from response
                let assistantMessage = '';
                let thinkingContent = '';
                
                // Handle content blocks (may include thinking blocks)
                if (data.content && Array.isArray(data.content)) {
                    for (const block of data.content) {
                        if (block.type === 'thinking') {
                            thinkingContent = block.thinking || '';
                        } else if (block.type === 'text') {
                            assistantMessage += block.text;
                        }
                    }
                }
                
                // Update token counts from API response
                if (data.usage) {
                    sessionTokens.input += data.usage.input_tokens || 0;
                    sessionTokens.output += data.usage.output_tokens || 0;
                    sessionTokens.total = sessionTokens.input + sessionTokens.output;
                    updateSessionTokensDisplay();
                }
                
                // Add assistant response to chat with markdown rendering
                await addMessageToChat('assistant', assistantMessage, thinkingContent);
                
                // Add to conversation history (store the full message)
                conversationHistory.push({
                    role: 'assistant',
                    content: assistantMessage
                });

                // Update delete buttons after adding new message
                updateDeleteButtons();

                updateDebugInfo('Message sent successfully');

            } catch (error) {
                removeLoading(loadingId);
                showError(error.message);
                updateDebugInfo(`Error: ${error.message}`);
                console.error('Error:', error);
                
                // Provide specific help for common errors
                if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                    showError('CORS blocking detected. See console for solutions.');
                }
            } finally {
                sendButton.disabled = false;
				messageInput.focus();
            }
        }

        function processThinkingContent(content) {
            // This function is kept for backward compatibility with saved chats
            // that might have thinking tags in the content
            const thinkingRegex = /<thinking>([\s\S]*?)<\/thinking>/g;
            let thinkingContent = '';
            let displayContent = content;
            
            const matches = [...content.matchAll(thinkingRegex)];
            if (matches.length > 0) {
                // Extract all thinking blocks
                thinkingContent = matches.map(match => match[1].trim()).join('\n\n');
                // Remove thinking blocks from display content
                displayContent = content.replace(thinkingRegex, '').trim();
            }
            
            return {
                displayContent,
                thinkingContent
            };
        }

        async function addMessageToChat(role, content, thinkingContent = null, addToHistory = true) {
            const chatContainer = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const avatar = role === 'user' ? 'U' : 'C';
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            avatarDiv.textContent = avatar;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (role === 'assistant') {
                try {
                    // Add thinking content if present and showThinking is enabled
                    if (thinkingContent && showThinking) {
                        const thinkingDiv = document.createElement('details');
                        thinkingDiv.className = 'thinking-content';
                        thinkingDiv.innerHTML = `
                            <summary>💭 View thinking process</summary>
                            <div>${escapeHtml(thinkingContent)}</div>
                        `;
                        contentDiv.appendChild(thinkingDiv);
                    }
                    
                    // Parse and render markdown for assistant messages
                    const renderedContent = renderMarkdownWithCodeBlocks(content);
                    const mainContentDiv = document.createElement('div');
                    mainContentDiv.innerHTML = renderedContent;
                    contentDiv.appendChild(mainContentDiv);
                    
                    // Wait for code blocks to be processed
                    await new Promise(resolve => {
                        setTimeout(() => {
                            addCopyButtonsToCodeBlocks(contentDiv);
                            checkAndAdjustContainerWidth();
                            resolve();
                        }, 100);
                    });
                } catch (e) {
                    console.error('Error rendering markdown:', e);
                    // Fallback to plain text
                    contentDiv.textContent = content;
                }
            } else {
                // For user messages, just escape HTML and preserve newlines
                contentDiv.textContent = content;
            }
            
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Check if width adjustment is needed
            setTimeout(checkAndAdjustContainerWidth, 50);
        }

		function renderMarkdownWithCodeBlocks(content) {
			// Use a more robust approach to extract code blocks
			const codeBlocks = [];
			let processedContent = '';
			let lastIndex = 0;
			let inCodeBlock = false;
			let codeBlockStart = -1;
			let currentLang = '';
			
			// Split by lines to process more carefully
			const lines = content.split('\n');
			let i = 0;
			
			while (i < lines.length) {
				const line = lines[i];
				
				// Check for code block delimiter
				if (line.trim().startsWith('```')) {
					if (!inCodeBlock) {
						// Starting a code block
						inCodeBlock = true;
						codeBlockStart = i;
						// Extract language (everything after ``` on the same line)
						currentLang = line.trim().substring(3).trim();
						i++;
					} else {
						// Ending a code block
						inCodeBlock = false;
						
						// Extract the code content
						const codeLines = lines.slice(codeBlockStart + 1, i);
						const code = codeLines.join('\n');
						
						const index = codeBlocks.length;
						codeBlocks.push({ 
							lang: currentLang || 'plaintext', 
							code: code 
						});
						
						processedContent += `%%%CODEBLOCK${index}%%%\n`;
						currentLang = '';
						i++;
					}
				} else {
					// Regular line
					if (!inCodeBlock) {
						processedContent += line + '\n';
					}
					i++;
				}
			}
			
			// If we're still in a code block at the end (malformed), treat remaining as code
			if (inCodeBlock) {
				const codeLines = lines.slice(codeBlockStart + 1);
				const code = codeLines.join('\n');
				const index = codeBlocks.length;
				codeBlocks.push({ 
					lang: currentLang || 'plaintext', 
					code: code 
				});
				processedContent += `%%%CODEBLOCK${index}%%%\n`;
			}
			
			// Parse the markdown
			let html = marked.parse(processedContent);
			
			// Replace placeholders with properly formatted code blocks
			html = html.replace(/%%%CODEBLOCK(\d+)%%%/g, (match, index) => {
				const block = codeBlocks[parseInt(index)];
				return createCodeBlock(block.code, block.lang);
			});
			
			return html;
		}

		function createCodeBlock(code, language) {
			// Map common language aliases
			const languageMap = {
				'py': 'python',
				'js': 'javascript',
				'ts': 'typescript',
				'sh': 'bash',
				'yml': 'yaml',
				'html': 'markup',
				'xml': 'markup',
				'pas': 'pascal',
				'dpr': 'pascal',
				'freepascal': 'pascal',
				'objectpascal': 'pascal',
				'lazarus': 'pascal'
			};
			
			const mappedLang = languageMap[language] || language;
			let highlightedCode;
			
			// Don't trim the code - preserve exact formatting
			const codeToHighlight = code;
			
			try {
				if (Prism.languages[mappedLang]) {
					highlightedCode = Prism.highlight(codeToHighlight, Prism.languages[mappedLang], mappedLang);
				} else {
					// If language not supported, use plain text
					highlightedCode = escapeHtml(codeToHighlight);
				}
			} catch (e) {
				console.warn(`Error highlighting ${mappedLang}:`, e);
				highlightedCode = escapeHtml(codeToHighlight);
			}
			
			return `<div class="code-block-wrapper">
						<pre><code class="language-${escapeHtml(mappedLang)}">${highlightedCode}</code></pre>
					</div>`;
		}

        function addCopyButtonsToCodeBlocks(container) {
            const codeBlocks = container.querySelectorAll('.code-block-wrapper');
            
            codeBlocks.forEach(block => {
                // Check if button already exists
                if (block.querySelector('.copy-button')) return;
                
                const button = document.createElement('button');
                button.className = 'copy-button';
                button.textContent = 'Copy';
                
                button.onclick = function() {
                    const code = block.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        alert('Failed to copy to clipboard');
                    });
                };
                
                block.appendChild(button);
            });
        }

        function showLoading() {
            const chatContainer = document.getElementById('chatContainer');
            const loadingDiv = document.createElement('div');
            const loadingId = 'loading-' + Date.now();
            loadingDiv.id = loadingId;
            loadingDiv.className = 'message assistant';
            loadingDiv.innerHTML = `
                <div class="message-avatar">C</div>
                <div class="message-content loading">
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                </div>
            `;
            chatContainer.appendChild(loadingDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return loadingId;
        }

        function removeLoading(loadingId) {
            const loadingDiv = document.getElementById(loadingId);
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        function showError(message) {
            const chatContainer = document.getElementById('chatContainer');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = `<strong>Error:</strong> ${escapeHtml(message)}`;
            chatContainer.appendChild(errorDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add proxy server example
        console.log(`
=== IMPORTANT: CORS Information ===

The Anthropic API blocks direct browser requests due to CORS policy.
Here are your options:

1. LOCAL PROXY SERVER (Recommended)
   Create a simple Node.js proxy server:
   
   Save this as 'proxy-server.js':
   ----------------------------------------
   const express = require('express');
   const cors = require('cors');
   const fetch = require('node-fetch');
   
   const app = express();
   app.use(cors());
   app.use(express.json());
   
   app.post('/api/messages', async (req, res) => {
     try {
       const response = await fetch('https://api.anthropic.com/v1/messages', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'x-api-key': req.headers['x-api-key'],
           'anthropic-version': '2023-06-01'
         },
         body: JSON.stringify(req.body)
       });
       
       const data = await response.json();
       res.json(data);
     } catch (error) {
       res.status(500).json({ error: error.message });
     }
   });
   
   app.listen(3000, () => {
     console.log('Proxy server running on http://localhost:3000');
   });
   ----------------------------------------
   
   Then run:
   npm install express cors node-fetch
   node proxy-server.js
   
   And update the API_URL in this HTML to: http://localhost:3000/api/messages

2. CHROME WITH DISABLED SECURITY (Development only):
   Mac: open -n -a /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --args --user-data-dir="/tmp/chrome_dev_test" --disable-web-security
   Windows: chrome.exe --user-data-dir="C:/Chrome dev session" --disable-web-security
   Linux: google-chrome --user-data-dir="/tmp/chrome_dev_test" --disable-web-security

3. USE A PUBLIC CORS PROXY (Not recommended for production):
   Update API_URL to: https://cors-anywhere.herokuapp.com/https://api.anthropic.com/v1/messages
        `);
    </script>
</body>
</html>
