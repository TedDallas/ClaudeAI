<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Tunnel Runner</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        body.fullscreen-active {
            cursor: none;
        }
        
        body.fullscreen-active * {
            cursor: none;
        }
        
        body:not(.fullscreen-active) button:hover {
            cursor: pointer;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 22px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            user-select: none;
            pointer-events: none;
            text-align: center;
            padding-top: env(safe-area-inset-top);
        }
        
        #ui div {
            margin-bottom: 8px;
        }
        
        #highScoreDisplay {
            color: #ffd700;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            transition: opacity 0.5s;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        #instructions.mobile-instructions {
            text-align: center;
            font-size: 16px;
        }
        
        #fullscreenIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            background: rgba(0,0,0,0.85);
            padding: 50px 80px;
            border-radius: 20px;
            border: 3px solid #ff3333;
            box-shadow: 0 0 50px rgba(255,0,0,0.5);
        }
        
        #gameOver h1 {
            color: #ff3333;
            font-size: 56px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,0,0,0.8);
        }
        
        #gameOver p {
            color: #fff;
            font-size: 28px;
            margin-bottom: 15px;
        }
        
        #restartBtn {
            padding: 18px 50px;
            font-size: 22px;
            cursor: pointer;
            background: linear-gradient(145deg, #ff4444, #cc0000);
            color: white;
            border: none;
            border-radius: 10px;
            transition: all 0.3s ease;
            margin-top: 15px;
        }
        
        #restartBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255,0,0,0.6);
        }
        
        .restart-hint {
            font-size: 16px !important;
            color: #888 !important;
            margin-top: 20px !important;
        }
        
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 50px 80px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            box-shadow: 0 0 50px rgba(0,255,136,0.3);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #startScreen h1 {
            color: #00ff88;
            font-size: 52px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0,255,136,0.8);
        }
        
        #startScreen p {
            color: #ccc;
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .key {
            display: inline-block;
            background: linear-gradient(145deg, #444, #222);
            color: #fff;
            padding: 5px 12px;
            border-radius: 5px;
            border: 1px solid #666;
            font-family: monospace;
            font-weight: bold;
            margin: 0 3px;
        }
        
        .mobile-control {
            display: inline-block;
            background: linear-gradient(145deg, #00aa55, #006633);
            color: #fff;
            padding: 8px 15px;
            border-radius: 10px;
            font-weight: bold;
            margin: 5px;
        }
        
        #startBtn {
            padding: 18px 60px;
            font-size: 24px;
            cursor: pointer;
            background: linear-gradient(145deg, #00ff88, #00aa55);
            color: #000;
            border: none;
            border-radius: 10px;
            margin-top: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        #startBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0,255,136,0.6);
        }
        
        .fullscreen-note {
            color: #888;
            font-size: 14px;
            margin-top: 15px;
        }
        
        .version-number {
            color: #555;
            font-size: 12px;
            margin-top: 20px;
            font-family: monospace;
        }
        
        .desktop-only {
            display: block;
        }
        
        .mobile-only {
            display: none;
        }
        
        body.is-mobile .desktop-only {
            display: none;
        }
        
        body.is-mobile .mobile-only {
            display: block;
        }
        
        /* Mobile-specific start screen styles */
        body.is-mobile #startScreen {
            padding: 20px 25px;
            max-width: 92vw;
            max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 20px);
            max-height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 20px);
            border-radius: 15px;
            border-width: 2px;
        }
        
        body.is-mobile #startScreen h1 {
            font-size: 28px;
            margin-bottom: 15px;
        }
        
        body.is-mobile #startScreen p {
            font-size: 13px;
            margin-bottom: 8px;
            line-height: 1.3;
        }
        
        body.is-mobile #startScreen .mobile-control {
            padding: 5px 10px;
            font-size: 12px;
            margin: 3px;
            border-radius: 6px;
        }
        
        body.is-mobile #startBtn {
            padding: 12px 40px;
            font-size: 18px;
            margin-top: 12px;
            border-radius: 8px;
        }
        
        body.is-mobile #startScreen .fullscreen-note {
            font-size: 11px;
            margin-top: 10px;
            line-height: 1.4;
        }
        
        body.is-mobile #startScreen .version-number {
            font-size: 10px;
            margin-top: 10px;
        }
        
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            background: rgba(0,0,0,0.9);
            padding: 50px 80px;
            border-radius: 20px;
            border: 3px solid #ffaa00;
            box-shadow: 0 0 50px rgba(255,170,0,0.5);
        }
        
        #pauseMenu h1 {
            color: #ffaa00;
            font-size: 56px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255,170,0,0.8);
        }
        
        #pauseMenu p {
            color: #fff;
            font-size: 22px;
            margin-bottom: 15px;
        }
        
        #resumeBtn {
            padding: 18px 50px;
            font-size: 22px;
            cursor: pointer;
            background: linear-gradient(145deg, #ffaa00, #cc8800);
            color: #000;
            border: none;
            border-radius: 10px;
            transition: all 0.3s ease;
            margin-top: 15px;
            font-weight: bold;
        }
        
        #resumeBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255,170,0,0.6);
        }
        
        .pause-hint {
            font-size: 16px !important;
            color: #888 !important;
            margin-top: 20px !important;
        }
        
        #highScoreCelebration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            background: rgba(0,0,0,0.9);
            padding: 50px 80px;
            border-radius: 20px;
            border: 3px solid #ffd700;
            box-shadow: 0 0 60px rgba(255,215,0,0.6);
            animation: celebrationPulse 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes celebrationPulse {
            from {
                box-shadow: 0 0 60px rgba(255,215,0,0.6);
            }
            to {
                box-shadow: 0 0 100px rgba(255,215,0,0.9);
            }
        }
        
        #highScoreCelebration .trophy {
            font-size: 120px;
            animation: trophyBounce 0.6s ease-in-out infinite;
        }
        
        @keyframes trophyBounce {
            0%, 100% {
                transform: translateY(0) rotate(-5deg);
            }
            50% {
                transform: translateY(-20px) rotate(5deg);
            }
        }
        
        #highScoreCelebration h1 {
            color: #ffd700;
            font-size: 48px;
            margin: 20px 0;
            text-shadow: 0 0 30px rgba(255,215,0,0.8);
        }
        
        #highScoreCelebration h2 {
            color: #fff;
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        #highScoreCelebration p {
            color: #ccc;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        #highScoreCelebration .newRecord {
            color: #ffd700;
            font-size: 28px;
            font-weight: bold;
        }
        
        #continueBtn {
            padding: 18px 50px;
            font-size: 22px;
            cursor: pointer;
            background: linear-gradient(145deg, #ffd700, #ffaa00);
            color: #000;
            border: none;
            border-radius: 10px;
            transition: all 0.3s ease;
            margin-top: 25px;
            font-weight: bold;
        }
        
        #continueBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255,215,0,0.8);
        }
        
        .continue-hint {
            font-size: 16px !important;
            color: #888 !important;
            margin-top: 20px !important;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
        }
        
        @keyframes confettiFall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        #mobilePauseBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: transparent;
            border: none;
            border-radius: 10px;
            font-size: 32px;
            cursor: pointer;
            display: none;
            z-index: 100;
            touch-action: manipulation;
            padding-top: env(safe-area-inset-top);
            text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.5);
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        #mobilePauseBtn:active {
            opacity: 1;
            transform: scale(1.1);
        }
        
        body.is-mobile #mobilePauseBtn {
            display: block;
        }
        
        body.is-mobile #fullscreenIndicator {
            display: none;
        }
        
        #tiltIndicator {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            pointer-events: none;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        body.is-mobile #tiltIndicator {
            display: block;
        }
        
        #tiltIndicator .indicator-bar {
            width: 150px;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        #tiltIndicator .indicator-dot {
            width: 16px;
            height: 16px;
            background: #00ff88;
            border-radius: 50%;
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 10px #00ff88;
            transition: left 0.1s ease-out;
        }
        
        /* Power-up Gauge Styles */
        #powerUpGauge {
            position: absolute;
            bottom: 100px;
            right: 30px;
            width: 80px;
            height: 80px;
            display: none;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #powerUpGauge.active {
            display: block;
            opacity: 1;
        }
        
        #powerUpGauge .gauge-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #powerUpGauge .gauge-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2), inset 0 0 20px rgba(255, 255, 255, 0.1);
        }
        
        #powerUpGauge .gauge-fill {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                #ffffff 0%,
                #ffff88 25%,
                #ffff00 50%,
                #ffaa00 75%,
                #ff8800 100%
            );
            mask: radial-gradient(transparent 55%, black 56%);
            -webkit-mask: radial-gradient(transparent 55%, black 56%);
            transform: rotate(-90deg);
            transition: clip-path 0.1s linear;
        }
        
        #powerUpGauge .gauge-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffffff, #aaaaaa);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 10px #ffffff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        #powerUpGauge .gauge-icon {
            font-size: 20px;
            animation: pulseIcon 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulseIcon {
            from {
                transform: scale(1);
                filter: brightness(1);
            }
            to {
                transform: scale(1.2);
                filter: brightness(1.5);
            }
        }
        
        #powerUpGauge .gauge-time {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff, 0 0 20px #aaaaaa;
            white-space: nowrap;
        }
        
        #powerUpGauge .gauge-sparks {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            animation: sparkRotate 2s linear infinite;
        }
        
        @keyframes sparkRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        #powerUpGauge .gauge-sparks::before,
        #powerUpGauge .gauge-sparks::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff;
        }
        
        #powerUpGauge .gauge-sparks::before {
            top: 0;
            left: 50%;
        }
        
        #powerUpGauge .gauge-sparks::after {
            bottom: 0;
            left: 50%;
        }
        
        /* Cubes destroyed counter */
        #cubesDestroyed {
            position: absolute;
            bottom: 100px;
            left: 30px;
            display: none;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
        }
        
        #cubesDestroyed.active {
            display: block;
            opacity: 1;
        }
        
        #cubesDestroyed .counter-value {
            font-size: 36px;
            font-weight: bold;
            color: #ff4444;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff4400;
        }
        
        #cubesDestroyed .counter-label {
            font-size: 12px;
            color: #ffaa00;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        /* iOS notch and safe area support */
        @supports (padding-top: env(safe-area-inset-top)) {
            #ui {
                padding-top: calc(20px + env(safe-area-inset-top));
            }
            
            #mobilePauseBtn {
                top: calc(10px + env(safe-area-inset-top));
            }
            
            #instructions {
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
            }
        }
        
        @media (max-width: 768px) {
            #startScreen {
                padding: 30px 40px;
            }
            
            #startScreen h1 {
                font-size: 36px;
            }
            
            #startScreen p {
                font-size: 14px;
            }
            
            #startBtn {
                padding: 15px 40px;
                font-size: 20px;
            }
            
            #gameOver {
                padding: 30px 40px;
            }
            
            #gameOver h1 {
                font-size: 36px;
            }
            
            #gameOver p {
                font-size: 20px;
            }
            
            #ui {
                font-size: 18px;
            }
            
            #pauseMenu {
                padding: 30px 40px;
            }
            
            #pauseMenu h1 {
                font-size: 36px;
            }
            
            #highScoreCelebration {
                padding: 30px 40px;
            }
            
            #highScoreCelebration .trophy {
                font-size: 80px;
            }
            
            #highScoreCelebration h1 {
                font-size: 32px;
            }
            
            #powerUpGauge {
                width: 60px;
                height: 60px;
                bottom: 80px;
                right: 20px;
            }
            
            #powerUpGauge .gauge-center {
                width: 36px;
                height: 36px;
                font-size: 12px;
            }
            
            #powerUpGauge .gauge-icon {
                font-size: 16px;
            }
            
            #powerUpGauge .gauge-time {
                font-size: 12px;
                bottom: -20px;
            }
        }
        
        /* Extra small screens (very small phones) */
        @media (max-height: 600px) {
            body.is-mobile #startScreen {
                padding: 15px 20px;
            }
            
            body.is-mobile #startScreen h1 {
                font-size: 24px;
                margin-bottom: 10px;
            }
            
            body.is-mobile #startScreen p {
                font-size: 11px;
                margin-bottom: 6px;
            }
            
            body.is-mobile #startScreen .mobile-control {
                padding: 4px 8px;
                font-size: 10px;
                margin: 2px;
            }
            
            body.is-mobile #startBtn {
                padding: 10px 30px;
                font-size: 16px;
                margin-top: 8px;
            }
            
            body.is-mobile #startScreen .fullscreen-note {
                font-size: 10px;
                margin-top: 8px;
            }
            
            body.is-mobile #startScreen .version-number {
                margin-top: 6px;
            }
        }
        
        /* Landscape mode on mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            body.is-mobile #startScreen {
                padding: 12px 30px;
                max-height: calc(100vh - 20px);
                max-height: calc(100dvh - 20px);
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            body.is-mobile #startScreen h1 {
                font-size: 22px;
                margin-bottom: 8px;
                width: 100%;
            }
            
            body.is-mobile #startScreen p {
                font-size: 10px;
                margin-bottom: 4px;
            }
            
            body.is-mobile #startScreen .mobile-control {
                padding: 3px 6px;
                font-size: 9px;
                margin: 2px;
            }
            
            body.is-mobile #startBtn {
                padding: 8px 25px;
                font-size: 14px;
                margin-top: 6px;
            }
            
            body.is-mobile #startScreen .fullscreen-note {
                font-size: 9px;
                margin-top: 6px;
            }
            
            body.is-mobile #startScreen .version-number {
                margin-top: 4px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="ui">
        <div>üìè Distance: <span id="distance">0</span>m</div>
        <div id="highScoreDisplay">üèÜ Best: <span id="bestDistance">0</span>m</div>
    </div>
    
    <button id="mobilePauseBtn">‚è∏Ô∏è</button>
    
    <div id="fullscreenIndicator">Press ESC to pause</div>
    
    <!-- Power-up Gauge -->
    <div id="powerUpGauge">
        <div class="gauge-container">
            <div class="gauge-bg"></div>
            <div class="gauge-fill" id="gaugeFill"></div>
            <div class="gauge-sparks"></div>
            <div class="gauge-center">
                <span class="gauge-icon">‚ö°</span>
            </div>
            <div class="gauge-time" id="gaugeTime">15.0s</div>
        </div>
    </div>
    
    <!-- Cubes Destroyed Counter -->
    <div id="cubesDestroyed">
        <div class="counter-value" id="destroyedCount">0</div>
        <div class="counter-label">üí• Destroyed</div>
    </div>
    
    <div id="instructions" class="desktop-only">
        ‚å®Ô∏è <span class="key">A</span> Roll Left | <span class="key">D</span> Roll Right | <span class="key">SPACE</span> / <span class="key">‚Üë</span> Jump | <span class="key">ESC</span> Pause | Roll around the tunnel to avoid the cubes!
    </div>
    
    <div id="instructions" class="mobile-only mobile-instructions" style="display: none;">
        üì± Tilt device to roll | Tap screen to jump | Roll around the tunnel to avoid the cubes!
    </div>
    
    <div id="tiltIndicator">
        <div class="indicator-bar">
            <div class="indicator-dot" id="tiltDot"></div>
        </div>
    </div>
    
    <div id="startScreen">
        <h1>üéÆ TUNNEL RUNNER</h1>
        
        <div class="desktop-only">
            <p><span class="key">A</span> Roll LEFT along tunnel surface</p>
            <p><span class="key">D</span> Roll RIGHT along tunnel surface</p>
            <p><span class="key">SPACE</span> / <span class="key">‚Üë</span> Jump off the surface</p>
            <p><span class="key">ESC</span> Pause the game</p>
        </div>
        
        <div class="mobile-only">
            <p><span class="mobile-control">üì± TILT LEFT/RIGHT</span> Roll along tunnel</p>
            <p><span class="mobile-control">üëÜ TAP SCREEN</span> Jump off the surface</p>
            <p><span class="mobile-control">‚è∏Ô∏è</span> Tap pause button to pause</p>
        </div>
        
        <p>üåÄ Roll around the entire tunnel to dodge obstacles!</p>
        <p>üíÄ Avoid the CUBES or you explode!</p>
        <p>üíé Collect POWER GEMS for invincibility!</p>
        <p>üé® Cube colors change every 1000m!</p>
        <button id="startBtn">START GAME</button>
        
        <div class="desktop-only">
            <p class="fullscreen-note">üñ•Ô∏è Game will enter fullscreen mode<br><span class="key">ESC</span> to pause & exit fullscreen</p>
        </div>
        <div class="mobile-only">
            <p class="fullscreen-note">üì± Tilt your device to control the ball!<br>For best experience, add to Home Screen</p>
        </div>
        
        <p class="version-number">v0.10</p>
    </div>
    
    <div id="pauseMenu">
        <h1>‚è∏Ô∏è PAUSED</h1>
        <p>Game paused</p>
        <button id="resumeBtn">‚ñ∂Ô∏è Resume</button>
        <p class="pause-hint desktop-only">Press <span class="key">SPACE</span> or <span class="key">‚Üë</span> to resume</p>
        <p class="pause-hint mobile-only">Tap to resume</p>
    </div>
    
    <div id="highScoreCelebration">
        <div class="trophy">üèÜ</div>
        <h1>NEW RECORD!</h1>
        <h2>CONGRATULATIONS!</h2>
        <p class="newRecord">You traveled <span id="celebrationDistance">0</span>m!</p>
        <p>Previous best: <span id="previousBest">0</span>m</p>
        <button id="continueBtn">CONTINUE</button>
        <p class="continue-hint desktop-only">Press <span class="key">SPACE</span> or <span class="key">‚Üë</span> to continue</p>
        <p class="continue-hint mobile-only">Tap to continue</p>
    </div>
    
    <div id="gameOver">
        <h1>üí• GAME OVER</h1>
        <p>Distance: <span id="finalDistance">0</span>m</p>
        <p style="font-size: 20px; color: #aaa;">Best: <span id="gameOverBest">0</span>m</p>
        <button id="restartBtn">üîÑ Play Again</button>
        <p class="restart-hint desktop-only">Press <span class="key">SPACE</span> or <span class="key">‚Üë</span> to restart</p>
        <p class="restart-hint mobile-only">Tap to play again</p>
    </div>

    <script>
        // ============================================
        // TUNNEL RUNNER - Babylon.js 3D Game
        // Mobile + Desktop Support
        // Version 0.09 - Enhanced Power-up Effects
        // ============================================
        
        const GAME_VERSION = "0.09";
        
        let instructionsShownThisSession = false;
        
        // ============================================
        // MOBILE & iOS DETECTION
        // ============================================
        
        let isMobile = false;
        let isIOS = false;
        let isSafari = false;
        let accelerometerEnabled = false;
        let deviceGamma = 0;
        let accelerometerPermissionRequested = false;
        
        function detectMobile() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile|tablet/i;
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            const isSmallScreen = window.innerWidth <= 1024;
            
            return mobileRegex.test(userAgent.toLowerCase()) || (isTouchDevice && isSmallScreen);
        }
        
        function detectIOS() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return /iPad|iPhone|iPod/.test(userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }
        
        function detectSafari() {
            const userAgent = navigator.userAgent || '';
            return /^((?!chrome|android).)*safari/i.test(userAgent);
        }
        
        function setupMobileMode() {
            isMobile = detectMobile();
            isIOS = detectIOS();
            isSafari = detectSafari();
            
            if (isMobile) {
                document.body.classList.add('is-mobile');
                console.log('Mobile device detected - enabling touch and accelerometer controls');
                console.log('iOS:', isIOS, 'Safari:', isSafari);
                setupTouchControls();
            } else {
                document.body.classList.remove('is-mobile');
                console.log('Desktop device detected - using keyboard controls');
            }
        }
        
        async function requestAccelerometerPermission() {
            if (accelerometerPermissionRequested) return accelerometerEnabled;
            accelerometerPermissionRequested = true;
            
            if (typeof DeviceOrientationEvent === 'undefined') {
                console.warn('DeviceOrientationEvent not supported');
                return false;
            }
            
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        accelerometerEnabled = true;
                        window.addEventListener('deviceorientation', handleDeviceOrientation);
                        console.log('Accelerometer permission granted');
                        return true;
                    } else {
                        console.warn('Accelerometer permission denied');
                        return false;
                    }
                } catch (error) {
                    console.error('Error requesting accelerometer permission:', error);
                    return false;
                }
            } else {
                accelerometerEnabled = true;
                window.addEventListener('deviceorientation', handleDeviceOrientation);
                console.log('Accelerometer enabled (no permission required)');
                return true;
            }
        }
        
        function handleDeviceOrientation(event) {
            if (!accelerometerEnabled || !gameState.isRunning || gameState.isPaused) return;
            deviceGamma = event.gamma || 0;
            updateTiltIndicator(deviceGamma);
        }
        
        function updateTiltIndicator(gamma) {
            const tiltDot = document.getElementById('tiltDot');
            if (tiltDot) {
                const clampedGamma = Math.max(-45, Math.min(45, gamma));
                const percentage = ((clampedGamma + 45) / 90) * 100;
                tiltDot.style.left = percentage + '%';
            }
        }
        
        function setupTouchControls() {
            const canvas = document.getElementById('renderCanvas');
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchstart', handleDocumentTouch, { passive: false });
        }
        
        function handleTouchStart(event) {
            event.preventDefault();
            if (!gameState.isRunning || gameState.isGameOver || gameState.isPaused) return;
            keys.jump = true;
        }
        
        function handleTouchEnd(event) {
            event.preventDefault();
            keys.jump = false;
        }
        
        function handleTouchMove(event) {
            event.preventDefault();
        }
        
        function handleDocumentTouch(event) {
            const target = event.target;
            if (target.tagName === 'BUTTON') return;
            
            if (gameState.isPaused && pauseMenu.style.display === 'block') {
                if (!pauseMenu.contains(target) || target === pauseMenu) {
                    event.preventDefault();
                    resumeGame();
                    return;
                }
            }
            
            if (highScoreCelebration.style.display === 'block') {
                if (!highScoreCelebration.contains(target) || target === highScoreCelebration) {
                    event.preventDefault();
                    continueToProceed();
                    return;
                }
            }
            
            if (gameState.isGameOver && gameOverElement.style.display === 'block') {
                if (!gameOverElement.contains(target) || target === gameOverElement) {
                    event.preventDefault();
                    restartGame();
                    return;
                }
            }
        }
        
        // ============================================
        // NEON COLOR GENERATION
        // (Neon Green removed - reserved for power-up)
        // ============================================
        
        const NEON_COLORS = [
            { name: 'Neon Red', hue: 0, saturation: 1.0, value: 1.0 },
            { name: 'Neon Orange', hue: 30, saturation: 1.0, value: 1.0 },
            { name: 'Neon Yellow', hue: 60, saturation: 1.0, value: 1.0 },
            { name: 'Neon Lime', hue: 90, saturation: 1.0, value: 1.0 },
            // Neon Green (hue: 120) REMOVED - reserved for power-up gem
            { name: 'Neon Cyan', hue: 180, saturation: 1.0, value: 1.0 },
            { name: 'Neon Blue', hue: 200, saturation: 1.0, value: 1.0 },
            { name: 'Neon Purple', hue: 280, saturation: 1.0, value: 1.0 },
            { name: 'Neon Magenta', hue: 300, saturation: 1.0, value: 1.0 },
            { name: 'Neon Pink', hue: 330, saturation: 1.0, value: 1.0 },
        ];
        
        function generateRandomNeonColor(excludeIndex) {
            let validIndices = [];
            for (let i = 0; i < NEON_COLORS.length; i++) {
                if (i !== excludeIndex) {
                    validIndices.push(i);
                }
            }
            
            const randomIndex = validIndices[Math.floor(Math.random() * validIndices.length)];
            const neonBase = NEON_COLORS[randomIndex];
            
            const hue = (neonBase.hue + (Math.random() - 0.5) * 20 + 360) % 360;
            const saturation = 0.9 + Math.random() * 0.1;
            const value = 0.95 + Math.random() * 0.05;
            
            const color = BABYLON.Color3.FromHSV(hue, saturation, value);
            const emissive = BABYLON.Color3.FromHSV(hue, saturation * 0.9, value * 0.7);
            
            console.log(`Generated neon color: ${neonBase.name} (index: ${randomIndex}, hue: ${Math.round(hue)})`);
            
            return {
                index: randomIndex,
                name: neonBase.name,
                hue: hue,
                saturation: saturation,
                value: value,
                color: color,
                emissive: emissive
            };
        }
        
        // Game Configuration
        const CONFIG = {
            ballRadius: 1.0,
            tunnelRadius: 10,
            tunnelSegmentLength: 40,
            tunnelSegmentsAhead: 12,
            tunnelSegmentsBehind: 2,
            tunnelSegmentsDeletionBuffer: 5,
            ballXOffset: 12,
            baseSpeed: 1.0,
            maxSpeed: 1.2,
            speedIncrement: 0.00006,
            
            angularAcceleration: 0.004,
            angularMaxSpeed: 0.12,
            angularFriction: 0.985,
            angularGravity: 0.006,
            
            tiltSensitivity: 0.00015,
            tiltDeadzone: 3,
            tiltMaxAngle: 45,
            
            jumpForce: 0.35,
            radialGravity: 0.014,
            
            obstacleFrequency: 0.65,
            minObstaclesPerSegment: 2,
            maxObstaclesPerSegment: 6,
            explosionParticles: 300,
            obstacleColorChangeInterval: 1000,
            
            tunnelBendHorizontal: 0.35,
            tunnelBendVertical: 0.4,
            tunnelMaxAngleH: 1.2,
            tunnelMaxAngleV: 1.1,
            
            dramaticEventChance: 0.15,
            dramaticDropStrength: 0.8,
            dramaticCurveStrength: 0.7,
            
            cameraPositionSmoothing: 0.03,
            cameraTargetSmoothing: 0.04,
            cameraLookAheadDistance: 15,
            
            pathSubdivisions: 30,
            
            guideLineStartT: 0.08,
            guideLineEndT: 0.92,
            
            trailFireParticles: 600,
            trailSmokeParticles: 300,
            trailSparkParticles: 200,
            
            // Power-up Configuration
            powerUpMinDistance: 200,
            powerUpMaxDistance: 500,
            powerUpSpawnAheadDistance: 350,
            invincibilityDuration: 15,
            speedBoostMultiplier: 2.0,
            speedBoostHoldTime: 1.0,
            speedDecelerationTime: 3.0,
            
            // NEW: Power-up warning and cube flash settings
            powerUpWarningTime: 3.0,      // Seconds before expiry to start warning
            ballFlashSpeed: 6,            // Flashes per second for ball warning
            cubeFlashSpeed: 4             // Flashes per second for cube rhythm
        };

        const keys = {
            left: false,
            right: false,
            jump: false
        };

        let gameState = {
            isRunning: false,
            isGameOver: false,
            isPaused: false,
            distance: 0,
            highScore: 0,
            speed: CONFIG.baseSpeed,
            
            theta: Math.PI,
            angularVelocity: 0,
            
            radialPosition: CONFIG.tunnelRadius - CONFIG.ballRadius,
            radialVelocity: 0,
            isGrounded: true,
            
            ballRotationX: 0,
            ballRotationZ: 0,
            
            currentSegmentIndex: 0,
            tunnelPath: [],
            smoothedPath: [],
            
            smoothedCameraPos: null,
            smoothedCameraTarget: null,
            smoothedUp: null,
            
            currentTunnelDir: new BABYLON.Vector3(0, 0, 1),
            
            isFullscreen: false,
            
            gameplayTime: 0,
            instructionsDismissed: false,
            
            currentObstacleColor: null,
            lastColorChangeDistance: -1,
            
            // Power-up State
            isInvincible: false,
            invincibilityTimeRemaining: 0,
            invincibilityWindingDown: false,
            nextGemDistance: 0,
            cubesDestroyed: 0,
            currentMaxSpeed: CONFIG.maxSpeed,
            speedBoostTimer: 0,
            isDecelerating: false,
            preBoostSpeed: CONFIG.baseSpeed,
            
            // NEW: Timer for ball color flash effect
            powerUpFlashTime: 0
        };

        let canvas, engine, scene, camera;
        let ball, ballDecal, ballMaterial, ballTrail;
        let tunnelSegments = [];
        let obstacles = [];
        let explosionParticles;
        let glowLayer;
        
        let fireTrailParticles;
        let smokeTrailParticles;
        let sparkTrailParticles;
        let coreGlowParticles;
        
        // Power-up related
        let powerUpGem = null;
        let gemSparkParticles = null;
        let gemGlowParticles = null;
        let invincibilityFieldParticles = null;
        let invincibilitySparkParticles = null;
        let cubeExplosionParticles = null;

        const distanceElement = document.getElementById('distance');
        const bestDistanceElement = document.getElementById('bestDistance');
        const gameOverElement = document.getElementById('gameOver');
        const finalDistanceElement = document.getElementById('finalDistance');
        const gameOverBestElement = document.getElementById('gameOverBest');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const highScoreCelebration = document.getElementById('highScoreCelebration');
        const celebrationDistanceElement = document.getElementById('celebrationDistance');
        const previousBestElement = document.getElementById('previousBest');
        const continueBtn = document.getElementById('continueBtn');
        const fullscreenIndicator = document.getElementById('fullscreenIndicator');
        const pauseMenu = document.getElementById('pauseMenu');
        const resumeBtn = document.getElementById('resumeBtn');
        const instructionsElement = document.getElementById('instructions');
        const mobilePauseBtn = document.getElementById('mobilePauseBtn');
        const powerUpGaugeElement = document.getElementById('powerUpGauge');
        const gaugeFillElement = document.getElementById('gaugeFill');
        const gaugeTimeElement = document.getElementById('gaugeTime');
        const cubesDestroyedElement = document.getElementById('cubesDestroyed');
        const destroyedCountElement = document.getElementById('destroyedCount');

        // ============================================
        // FULLSCREEN FUNCTIONS
        // ============================================
        
        function requestFullscreen() {
            const elem = document.documentElement;
            
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(err => {
                    console.log('Fullscreen request failed:', err);
                    if (isMobile) {
                        enterMobileFullscreen();
                    }
                });
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.webkitEnterFullscreen) {
                elem.webkitEnterFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (isMobile) {
                enterMobileFullscreen();
            }
        }
        
        function enterMobileFullscreen() {
            window.scrollTo(0, 1);
            
            document.body.style.position = 'fixed';
            document.body.style.top = '0';
            document.body.style.left = '0';
            document.body.style.right = '0';
            document.body.style.bottom = '0';
            document.body.style.width = '100%';
            document.body.style.height = '100%';
            
            if (engine) {
                setTimeout(() => {
                    engine.resize();
                }, 100);
            }
            
            gameState.isFullscreen = true;
            console.log('Mobile fullscreen mode activated');
        }
        
        function exitMobileFullscreen() {
            gameState.isFullscreen = false;
            console.log('Mobile fullscreen mode deactivated');
        }
        
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => {
                    console.log('Exit fullscreen failed:', err);
                });
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            
            if (isMobile) {
                exitMobileFullscreen();
            }
        }
        
        function isInFullscreen() {
            return !!(document.fullscreenElement || 
                     document.webkitFullscreenElement || 
                     document.mozFullScreenElement || 
                     document.msFullscreenElement) ||
                   gameState.isFullscreen;
        }
        
        function handleFullscreenChange() {
            const wasFullscreen = gameState.isFullscreen;
            const isNowFullscreen = !!(document.fullscreenElement || 
                                       document.webkitFullscreenElement || 
                                       document.mozFullScreenElement || 
                                       document.msFullscreenElement);
            
            gameState.isFullscreen = isNowFullscreen;
            
            if (isNowFullscreen) {
                document.body.classList.add('fullscreen-active');
                fullscreenIndicator.style.opacity = '1';
                
                setTimeout(() => {
                    if (gameState.isFullscreen) {
                        fullscreenIndicator.style.opacity = '0';
                    }
                }, 3000);
            } else {
                document.body.classList.remove('fullscreen-active');
                fullscreenIndicator.style.opacity = '0';
                
                if (!isMobile && wasFullscreen && gameState.isRunning && !gameState.isGameOver && !gameState.isPaused) {
                    pauseGame();
                }
            }
            
            if (engine) {
                engine.resize();
            }
        }

        // ============================================
        // PAUSE FUNCTIONS
        // ============================================
        
        function pauseGame() {
            if (!gameState.isRunning || gameState.isGameOver || gameState.isPaused) return;
            
            gameState.isPaused = true;
            pauseMenu.style.display = 'block';
            stopTrailParticles();
            stopInvincibilityEffects();
            
            if (isMobile) {
                exitFullscreen();
            }
        }
        
        function resumeGame() {
            if (!gameState.isPaused) return;
            
            gameState.isPaused = false;
            pauseMenu.style.display = 'none';
            startTrailParticles();
            if (gameState.isInvincible) {
                startInvincibilityEffects();
            }
            
            requestFullscreen();
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        
        function init() {
            setupMobileMode();
            
            canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
            
            loadHighScore();
            createScene();
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', restartGame);
            continueBtn.addEventListener('click', continueToProceed);
            resumeBtn.addEventListener('click', resumeGame);
            
            if (mobilePauseBtn) {
                mobilePauseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (gameState.isRunning && !gameState.isGameOver && !gameState.isPaused) {
                        pauseGame();
                    }
                });
                mobilePauseBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                });
            }
            
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
            
            window.addEventListener('resize', () => {
                engine.resize();
                const wasMobile = isMobile;
                setupMobileMode();
                if (wasMobile !== isMobile) {
                    console.log('Device type changed:', isMobile ? 'mobile' : 'desktop');
                }
            });
            
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (engine) {
                        engine.resize();
                    }
                    if (isMobile && gameState.isRunning && !gameState.isPaused) {
                        enterMobileFullscreen();
                    }
                }, 200);
            });
            
            fullscreenIndicator.style.opacity = '0';
            
            engine.runRenderLoop(() => {
                if (gameState.isRunning && !gameState.isGameOver && !gameState.isPaused) {
                    updateGame();
                }
                scene.render();
            });
        }
        
        function loadHighScore() {
            const saved = localStorage.getItem('tunnelRunnerHighScore');
            if (saved) {
                gameState.highScore = parseInt(saved, 10);
                bestDistanceElement.textContent = gameState.highScore;
            }
        }
        
        function saveHighScore() {
            localStorage.setItem('tunnelRunnerHighScore', gameState.highScore.toString());
        }
        
        function resetHighScore() {
            gameState.highScore = 0;
            saveHighScore();
            bestDistanceElement.textContent = '0';
        }

        function createScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.01, 0.01, 0.05, 1);
            
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            //scene.fogDensity = 0.012;
			scene.fogDensity = 0.006;
            scene.fogColor = new BABYLON.Color3(0.01, 0.01, 0.05);
            
            camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 2, -CONFIG.ballXOffset), scene);
            camera.fov = 0.8;
            
            const hemisphericLight = new BABYLON.HemisphericLight('hemiLight', new BABYLON.Vector3(0, 1, 0), scene);
            hemisphericLight.intensity = 0.7;
            hemisphericLight.groundColor = new BABYLON.Color3(0.2, 0.2, 0.4);
            
            const pointLight = new BABYLON.PointLight('pointLight', new BABYLON.Vector3(0, 0, 5), scene);
            pointLight.intensity = 3.5;
            pointLight.diffuse = new BABYLON.Color3(0.5, 0.8, 1);
            pointLight.range = 60;
            
            const ballLight = new BABYLON.PointLight('ballLight', new BABYLON.Vector3(0, 0, 0), scene);
            ballLight.intensity = 2.0;
            ballLight.diffuse = new BABYLON.Color3(0.3, 1, 0.5);
            ballLight.range = 25;
            
            const trailLight = new BABYLON.PointLight('trailLight', new BABYLON.Vector3(0, 0, 0), scene);
            trailLight.intensity = 1.5;
            trailLight.diffuse = new BABYLON.Color3(0.2, 0.8, 0.3);
            trailLight.range = 15;
            
            const rearLight = new BABYLON.PointLight('rearLight', new BABYLON.Vector3(0, 0, -10), scene);
            rearLight.intensity = 2.0;
            rearLight.diffuse = new BABYLON.Color3(0.4, 0.6, 1);
            rearLight.range = 40;
            
            glowLayer = new BABYLON.GlowLayer('glow', scene);
            glowLayer.intensity = 0.8;
            
            createBall();
            createBallTrailParticles();
            createExplosionParticles();
            createCubeExplosionParticles();
            createInvincibilityParticles();
            
            initializeObstacleColor();
            
            initializeTunnelPath();
            
            for (let i = -CONFIG.tunnelSegmentsBehind; i < CONFIG.tunnelSegmentsAhead; i++) {
                createTunnelSegment(i);
            }
        }
        
        function initializeObstacleColor() {
            gameState.currentObstacleColor = {
                index: 0,
                name: 'Neon Red',
                hue: 0,
                saturation: 1.0,
                value: 1.0,
                color: new BABYLON.Color3(1, 0.1, 0.05),
                emissive: new BABYLON.Color3(0.8, 0.05, 0.02)
            };
            gameState.lastColorChangeDistance = -1;
        }

        function createBall() {
            ball = BABYLON.MeshBuilder.CreateSphere('ball', { diameter: CONFIG.ballRadius * 2, segments: 32 }, scene);
            
            ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.9, 0.4);
            ballMaterial.emissiveColor = new BABYLON.Color3(0.08, 0.5, 0.25);
            ballMaterial.specularColor = new BABYLON.Color3(1, 1, 1);
            ballMaterial.specularPower = 64;
            ball.material = ballMaterial;
            
            ballDecal = BABYLON.MeshBuilder.CreateSphere('ballDecal', { diameter: CONFIG.ballRadius * 2.02, segments: 32 }, scene);
            const decalMat = new BABYLON.StandardMaterial('decalMat', scene);
            decalMat.diffuseColor = new BABYLON.Color3(0.05, 0.5, 0.2);
            decalMat.emissiveColor = new BABYLON.Color3(0.02, 0.25, 0.1);
            decalMat.alpha = 0.5;
            ballDecal.material = decalMat;
            ballDecal.parent = ball;
            
            glowLayer.addIncludedOnlyMesh(ball);
        }

        function createBallTrailParticles() {
            fireTrailParticles = new BABYLON.ParticleSystem('fireTrail', CONFIG.trailFireParticles, scene);
            
            const fireTexture = new BABYLON.DynamicTexture('fireTex', 64, scene);
            const fireCtx = fireTexture.getContext();
            const fireGradient = fireCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
            fireGradient.addColorStop(0, 'rgba(255,255,255,1)');
            fireGradient.addColorStop(0.15, 'rgba(200,255,150,1)');
            fireGradient.addColorStop(0.3, 'rgba(100,255,80,0.9)');
            fireGradient.addColorStop(0.5, 'rgba(50,200,50,0.6)');
            fireGradient.addColorStop(0.7, 'rgba(20,150,30,0.3)');
            fireGradient.addColorStop(1, 'rgba(0,80,0,0)');
            fireCtx.fillStyle = fireGradient;
            fireCtx.fillRect(0, 0, 64, 64);
            fireTexture.update();
            
            fireTrailParticles.particleTexture = fireTexture;
            fireTrailParticles.emitter = ball;
            
            fireTrailParticles.minEmitBox = new BABYLON.Vector3(-0.3, -0.3, 0.4);
            fireTrailParticles.maxEmitBox = new BABYLON.Vector3(0.3, 0.3, 0.8);
            
            fireTrailParticles.color1 = new BABYLON.Color4(0.6, 1, 0.4, 1);
            fireTrailParticles.color2 = new BABYLON.Color4(0.3, 0.9, 0.2, 1);
            fireTrailParticles.colorDead = new BABYLON.Color4(0, 0.4, 0, 0);
            
            fireTrailParticles.minSize = 0.3;
            fireTrailParticles.maxSize = 1.0;
            fireTrailParticles.minScaleX = 0.8;
            fireTrailParticles.maxScaleX = 1.2;
            fireTrailParticles.minScaleY = 1.0;
            fireTrailParticles.maxScaleY = 1.5;
            
            fireTrailParticles.minLifeTime = 0.15;
            fireTrailParticles.maxLifeTime = 0.4;
            fireTrailParticles.emitRate = 200;
            
            fireTrailParticles.direction1 = new BABYLON.Vector3(-0.3, -0.3, 0.8);
            fireTrailParticles.direction2 = new BABYLON.Vector3(0.3, 0.3, 1.5);
            fireTrailParticles.minEmitPower = 3;
            fireTrailParticles.maxEmitPower = 6;
            
            fireTrailParticles.gravity = new BABYLON.Vector3(0, 1, 0);
            fireTrailParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            fireTrailParticles.minAngularSpeed = -2;
            fireTrailParticles.maxAngularSpeed = 2;
            fireTrailParticles.updateSpeed = 0.02;
            
            fireTrailParticles.start();
            
            smokeTrailParticles = new BABYLON.ParticleSystem('smokeTrail', CONFIG.trailSmokeParticles, scene);
            
            const smokeTexture = new BABYLON.DynamicTexture('smokeTex', 64, scene);
            const smokeCtx = smokeTexture.getContext();
            const smokeGradient = smokeCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
            smokeGradient.addColorStop(0, 'rgba(150,200,150,0.5)');
            smokeGradient.addColorStop(0.3, 'rgba(80,150,80,0.35)');
            smokeGradient.addColorStop(0.6, 'rgba(40,100,40,0.2)');
            smokeGradient.addColorStop(1, 'rgba(20,60,20,0)');
            smokeCtx.fillStyle = smokeGradient;
            smokeCtx.fillRect(0, 0, 64, 64);
            smokeTexture.update();
            
            smokeTrailParticles.particleTexture = smokeTexture;
            smokeTrailParticles.emitter = ball;
            
            smokeTrailParticles.minEmitBox = new BABYLON.Vector3(-0.5, -0.5, 0.6);
            smokeTrailParticles.maxEmitBox = new BABYLON.Vector3(0.5, 0.5, 1.2);
            
            smokeTrailParticles.color1 = new BABYLON.Color4(0.3, 0.6, 0.3, 0.4);
            smokeTrailParticles.color2 = new BABYLON.Color4(0.15, 0.4, 0.15, 0.3);
            smokeTrailParticles.colorDead = new BABYLON.Color4(0.05, 0.15, 0.05, 0);
            
            smokeTrailParticles.minSize = 0.8;
            smokeTrailParticles.maxSize = 2.4;
            
            smokeTrailParticles.minLifeTime = 0.4;
            smokeTrailParticles.maxLifeTime = 1.0;
            smokeTrailParticles.emitRate = 80;
            
            smokeTrailParticles.direction1 = new BABYLON.Vector3(-0.5, -0.3, 0.5);
            smokeTrailParticles.direction2 = new BABYLON.Vector3(0.5, 0.5, 1.2);
            smokeTrailParticles.minEmitPower = 1;
            smokeTrailParticles.maxEmitPower = 2.5;
            
            smokeTrailParticles.gravity = new BABYLON.Vector3(0, 1.5, 0);
            smokeTrailParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;
            
            smokeTrailParticles.minAngularSpeed = -0.5;
            smokeTrailParticles.maxAngularSpeed = 0.5;
            
            smokeTrailParticles.start();
            
            sparkTrailParticles = new BABYLON.ParticleSystem('sparkTrail', CONFIG.trailSparkParticles, scene);
            
            const sparkTexture = new BABYLON.DynamicTexture('sparkTex', 32, scene);
            const sparkCtx = sparkTexture.getContext();
            const sparkGradient = sparkCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
            sparkGradient.addColorStop(0, 'rgba(255,255,255,1)');
            sparkGradient.addColorStop(0.2, 'rgba(200,255,180,1)');
            sparkGradient.addColorStop(0.5, 'rgba(100,255,100,0.8)');
            sparkGradient.addColorStop(1, 'rgba(0,200,0,0)');
            sparkCtx.fillStyle = sparkGradient;
            sparkCtx.fillRect(0, 0, 32, 32);
            sparkTexture.update();
            
            sparkTrailParticles.particleTexture = sparkTexture;
            sparkTrailParticles.emitter = ball;
            
            sparkTrailParticles.minEmitBox = new BABYLON.Vector3(-0.4, -0.4, 0.2);
            sparkTrailParticles.maxEmitBox = new BABYLON.Vector3(0.4, 0.4, 0.6);
            
            sparkTrailParticles.color1 = new BABYLON.Color4(0.8, 1, 0.6, 1);
            sparkTrailParticles.color2 = new BABYLON.Color4(0.4, 1, 0.3, 1);
            sparkTrailParticles.colorDead = new BABYLON.Color4(0, 0.5, 0, 0);
            
            sparkTrailParticles.minSize = 0.1;
            sparkTrailParticles.maxSize = 0.3;
            
            sparkTrailParticles.minLifeTime = 0.2;
            sparkTrailParticles.maxLifeTime = 0.6;
            sparkTrailParticles.emitRate = 60;
            
            sparkTrailParticles.direction1 = new BABYLON.Vector3(-1, -1, 0.5);
            sparkTrailParticles.direction2 = new BABYLON.Vector3(1, 1, 2);
            sparkTrailParticles.minEmitPower = 4;
            sparkTrailParticles.maxEmitPower = 10;
            
            sparkTrailParticles.gravity = new BABYLON.Vector3(0, -3, 0);
            sparkTrailParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            sparkTrailParticles.start();
            
            coreGlowParticles = new BABYLON.ParticleSystem('coreGlow', 100, scene);
            
            const coreTexture = new BABYLON.DynamicTexture('coreTex', 64, scene);
            const coreCtx = coreTexture.getContext();
            const coreGradient = coreCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
            coreGradient.addColorStop(0, 'rgba(255,255,255,1)');
            coreGradient.addColorStop(0.3, 'rgba(180,255,150,0.8)');
            coreGradient.addColorStop(0.6, 'rgba(100,255,80,0.4)');
            coreGradient.addColorStop(1, 'rgba(50,200,50,0)');
            coreCtx.fillStyle = coreGradient;
            coreCtx.fillRect(0, 0, 64, 64);
            coreTexture.update();
            
            coreGlowParticles.particleTexture = coreTexture;
            coreGlowParticles.emitter = ball;
            
            coreGlowParticles.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, 0.4);
            coreGlowParticles.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.5);
            
            coreGlowParticles.color1 = new BABYLON.Color4(0.9, 1, 0.8, 0.9);
            coreGlowParticles.color2 = new BABYLON.Color4(0.7, 1, 0.6, 0.8);
            coreGlowParticles.colorDead = new BABYLON.Color4(0.3, 0.8, 0.3, 0);
            
            coreGlowParticles.minSize = 0.6;
            coreGlowParticles.maxSize = 1.2;
            
            coreGlowParticles.minLifeTime = 0.05;
            coreGlowParticles.maxLifeTime = 0.15;
            coreGlowParticles.emitRate = 80;
            
            coreGlowParticles.direction1 = new BABYLON.Vector3(-0.1, -0.1, 0.3);
            coreGlowParticles.direction2 = new BABYLON.Vector3(0.1, 0.1, 0.6);
            coreGlowParticles.minEmitPower = 1;
            coreGlowParticles.maxEmitPower = 2;
            
            coreGlowParticles.gravity = new BABYLON.Vector3(0, 0, 0);
            coreGlowParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            coreGlowParticles.start();
        }
        
        // ============================================
        // INVINCIBILITY PARTICLE EFFECTS
        // ============================================
        
        function createInvincibilityParticles() {
            // Energy Field Particles - Changed to white
            invincibilityFieldParticles = new BABYLON.ParticleSystem('invincibilityField', 200, scene);
            
            const fieldTexture = new BABYLON.DynamicTexture('fieldTex', 64, scene);
            const fieldCtx = fieldTexture.getContext();
            const fieldGradient = fieldCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
            fieldGradient.addColorStop(0, 'rgba(255,255,255,1)');
            fieldGradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            fieldGradient.addColorStop(0.6, 'rgba(200,200,255,0.4)');
            fieldGradient.addColorStop(1, 'rgba(150,150,200,0)');
            fieldCtx.fillStyle = fieldGradient;
            fieldCtx.fillRect(0, 0, 64, 64);
            fieldTexture.update();
            
            invincibilityFieldParticles.particleTexture = fieldTexture;
            invincibilityFieldParticles.emitter = ball;
            
            invincibilityFieldParticles.createSphereEmitter(CONFIG.ballRadius * 1.5);
            
            invincibilityFieldParticles.color1 = new BABYLON.Color4(1, 1, 1, 0.8);
            invincibilityFieldParticles.color2 = new BABYLON.Color4(0.9, 0.9, 1, 0.6);
            invincibilityFieldParticles.colorDead = new BABYLON.Color4(0.8, 0.8, 1, 0);
            
            invincibilityFieldParticles.minSize = 0.2;
            invincibilityFieldParticles.maxSize = 0.5;
            
            invincibilityFieldParticles.minLifeTime = 0.3;
            invincibilityFieldParticles.maxLifeTime = 0.6;
            invincibilityFieldParticles.emitRate = 150;
            
            invincibilityFieldParticles.minEmitPower = 0.5;
            invincibilityFieldParticles.maxEmitPower = 1.5;
            
            invincibilityFieldParticles.gravity = new BABYLON.Vector3(0, 0, 0);
            invincibilityFieldParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            // Spark particles for invincibility - Changed to white
            invincibilitySparkParticles = new BABYLON.ParticleSystem('invincibilitySparks', 100, scene);
            
            const sparkTex = new BABYLON.DynamicTexture('invSparkTex', 32, scene);
            const sparkCtx = sparkTex.getContext();
            const sparkGrad = sparkCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
            sparkGrad.addColorStop(0, 'rgba(255,255,255,1)');
            sparkGrad.addColorStop(0.3, 'rgba(255,255,255,1)');
            sparkGrad.addColorStop(0.6, 'rgba(200,200,255,0.8)');
            sparkGrad.addColorStop(1, 'rgba(150,150,200,0)');
            sparkCtx.fillStyle = sparkGrad;
            sparkCtx.fillRect(0, 0, 32, 32);
            sparkTex.update();
            
            invincibilitySparkParticles.particleTexture = sparkTex;
            invincibilitySparkParticles.emitter = ball;
            
            invincibilitySparkParticles.createSphereEmitter(CONFIG.ballRadius * 1.2);
            
            invincibilitySparkParticles.color1 = new BABYLON.Color4(1, 1, 1, 1);
            invincibilitySparkParticles.color2 = new BABYLON.Color4(1, 1, 1, 1);
            invincibilitySparkParticles.colorDead = new BABYLON.Color4(0.8, 0.8, 1, 0);
            
            invincibilitySparkParticles.minSize = 0.05;
            invincibilitySparkParticles.maxSize = 0.15;
            
            invincibilitySparkParticles.minLifeTime = 0.1;
            invincibilitySparkParticles.maxLifeTime = 0.3;
            invincibilitySparkParticles.emitRate = 80;
            
            invincibilitySparkParticles.direction1 = new BABYLON.Vector3(-3, -3, -3);
            invincibilitySparkParticles.direction2 = new BABYLON.Vector3(3, 3, 3);
            invincibilitySparkParticles.minEmitPower = 5;
            invincibilitySparkParticles.maxEmitPower = 15;
            
            invincibilitySparkParticles.gravity = new BABYLON.Vector3(0, 0, 0);
            invincibilitySparkParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
        }
        
        function startInvincibilityEffects() {
            if (invincibilityFieldParticles) invincibilityFieldParticles.start();
            if (invincibilitySparkParticles) invincibilitySparkParticles.start();
            
            // Change ball appearance to bright white
            if (ballMaterial) {
                ballMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                ballMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
            }
        }
        
        function stopInvincibilityEffects() {
            if (invincibilityFieldParticles) invincibilityFieldParticles.stop();
            if (invincibilitySparkParticles) invincibilitySparkParticles.stop();
            
            // Restore ball appearance
            if (ballMaterial) {
                ballMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.9, 0.4);
                ballMaterial.emissiveColor = new BABYLON.Color3(0.08, 0.5, 0.25);
            }
        }
        
        // ============================================
        // NEW: TRAIL PARTICLE COLOR FUNCTIONS
        // ============================================
        
        function setTrailParticlesToWhite() {
            if (fireTrailParticles) {
                fireTrailParticles.color1 = new BABYLON.Color4(1, 1, 1, 1);
                fireTrailParticles.color2 = new BABYLON.Color4(0.95, 0.95, 1, 1);
                fireTrailParticles.colorDead = new BABYLON.Color4(0.6, 0.6, 0.7, 0);
            }
            if (smokeTrailParticles) {
                smokeTrailParticles.color1 = new BABYLON.Color4(0.9, 0.9, 0.95, 0.4);
                smokeTrailParticles.color2 = new BABYLON.Color4(0.7, 0.7, 0.8, 0.3);
                smokeTrailParticles.colorDead = new BABYLON.Color4(0.4, 0.4, 0.5, 0);
            }
            if (sparkTrailParticles) {
                sparkTrailParticles.color1 = new BABYLON.Color4(1, 1, 1, 1);
                sparkTrailParticles.color2 = new BABYLON.Color4(0.95, 0.95, 1, 1);
                sparkTrailParticles.colorDead = new BABYLON.Color4(0.6, 0.6, 0.7, 0);
            }
            if (coreGlowParticles) {
                coreGlowParticles.color1 = new BABYLON.Color4(1, 1, 1, 0.9);
                coreGlowParticles.color2 = new BABYLON.Color4(0.95, 0.95, 1, 0.8);
                coreGlowParticles.colorDead = new BABYLON.Color4(0.7, 0.7, 0.8, 0);
            }
            console.log('üé® Trail particles set to WHITE');
        }
        
        function setTrailParticlesToNormal() {
            if (fireTrailParticles) {
                fireTrailParticles.color1 = new BABYLON.Color4(0.6, 1, 0.4, 1);
                fireTrailParticles.color2 = new BABYLON.Color4(0.3, 0.9, 0.2, 1);
                fireTrailParticles.colorDead = new BABYLON.Color4(0, 0.4, 0, 0);
            }
            if (smokeTrailParticles) {
                smokeTrailParticles.color1 = new BABYLON.Color4(0.3, 0.6, 0.3, 0.4);
                smokeTrailParticles.color2 = new BABYLON.Color4(0.15, 0.4, 0.15, 0.3);
                smokeTrailParticles.colorDead = new BABYLON.Color4(0.05, 0.15, 0.05, 0);
            }
            if (sparkTrailParticles) {
                sparkTrailParticles.color1 = new BABYLON.Color4(0.8, 1, 0.6, 1);
                sparkTrailParticles.color2 = new BABYLON.Color4(0.4, 1, 0.3, 1);
                sparkTrailParticles.colorDead = new BABYLON.Color4(0, 0.5, 0, 0);
            }
            if (coreGlowParticles) {
                coreGlowParticles.color1 = new BABYLON.Color4(0.9, 1, 0.8, 0.9);
                coreGlowParticles.color2 = new BABYLON.Color4(0.7, 1, 0.6, 0.8);
                coreGlowParticles.colorDead = new BABYLON.Color4(0.3, 0.8, 0.3, 0);
            }
            console.log('üé® Trail particles set to NORMAL (green)');
        }
        
        // ============================================
        // NEW: CUBE FLASHING FUNCTIONS
        // ============================================
        
        function updateCubeFlashing() {
            if (!gameState.isInvincible) return;
            
            const time = performance.now() / 1000;
            // Create a rhythmic flash using sine wave (0 to 1)
            const flashIntensity = (Math.sin(time * Math.PI * CONFIG.cubeFlashSpeed) + 1) / 2;
            
            const baseColor = gameState.currentObstacleColor.color;
            const baseEmissive = gameState.currentObstacleColor.emissive;
            
            for (const obstacle of obstacles) {
                if (obstacle && obstacle.material && !obstacle.isDisposed()) {
                    // Flash between base color and bright white
                    const r = baseColor.r + (1 - baseColor.r) * flashIntensity;
                    const g = baseColor.g + (1 - baseColor.g) * flashIntensity;
                    const b = baseColor.b + (1 - baseColor.b) * flashIntensity;
                    
                    obstacle.material.diffuseColor.r = r;
                    obstacle.material.diffuseColor.g = g;
                    obstacle.material.diffuseColor.b = b;
                    
                    obstacle.material.emissiveColor.r = baseEmissive.r + (1 - baseEmissive.r) * flashIntensity;
                    obstacle.material.emissiveColor.g = baseEmissive.g + (1 - baseEmissive.g) * flashIntensity;
                    obstacle.material.emissiveColor.b = baseEmissive.b + (1 - baseEmissive.b) * flashIntensity;
                }
            }
        }
        
        function resetCubeColors() {
            const baseColor = gameState.currentObstacleColor.color;
            const baseEmissive = gameState.currentObstacleColor.emissive;
            
            for (const obstacle of obstacles) {
                if (obstacle && obstacle.material && !obstacle.isDisposed()) {
                    obstacle.material.diffuseColor = baseColor.clone();
                    obstacle.material.emissiveColor = baseEmissive.clone();
                }
            }
            console.log('üé® Cube colors reset to normal');
        }
        
        // ============================================
        // CUBE EXPLOSION PARTICLES
        // ============================================
        
        function createCubeExplosionParticles() {
            cubeExplosionParticles = new BABYLON.ParticleSystem('cubeExplosion', 200, scene);
            
            const explosionTex = new BABYLON.DynamicTexture('cubeExpTex', 64, scene);
            const ctx = explosionTex.getContext();
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,200,100,1)');
            grad.addColorStop(0.5, 'rgba(255,100,50,0.8)');
            grad.addColorStop(1, 'rgba(200,50,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            explosionTex.update();
            
            cubeExplosionParticles.particleTexture = explosionTex;
            cubeExplosionParticles.emitter = new BABYLON.Vector3(0, 0, 0);
            cubeExplosionParticles.minEmitBox = new BABYLON.Vector3(-0.5, -0.5, -0.5);
            cubeExplosionParticles.maxEmitBox = new BABYLON.Vector3(0.5, 0.5, 0.5);
            
            cubeExplosionParticles.color1 = new BABYLON.Color4(1, 0.8, 0.2, 1);
            cubeExplosionParticles.color2 = new BABYLON.Color4(1, 0.3, 0, 1);
            cubeExplosionParticles.colorDead = new BABYLON.Color4(0.5, 0, 0, 0);
            
            cubeExplosionParticles.minSize = 0.3;
            cubeExplosionParticles.maxSize = 0.8;
            cubeExplosionParticles.minLifeTime = 0.2;
            cubeExplosionParticles.maxLifeTime = 0.5;
            cubeExplosionParticles.emitRate = 0;
            cubeExplosionParticles.manualEmitCount = 0;
            
            cubeExplosionParticles.direction1 = new BABYLON.Vector3(-5, -5, -5);
            cubeExplosionParticles.direction2 = new BABYLON.Vector3(5, 5, 5);
            cubeExplosionParticles.minEmitPower = 10;
            cubeExplosionParticles.maxEmitPower = 20;
            
            cubeExplosionParticles.gravity = new BABYLON.Vector3(0, -5, 0);
            cubeExplosionParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            cubeExplosionParticles.start();
        }
        
        function triggerCubeExplosion(position, color) {
            if (cubeExplosionParticles) {
                cubeExplosionParticles.emitter = position.clone();
                cubeExplosionParticles.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1);
                cubeExplosionParticles.color2 = new BABYLON.Color4(color.r * 0.5, color.g * 0.5, color.b * 0.5, 1);
                cubeExplosionParticles.manualEmitCount = 100;
            }
        }
        
        // ============================================
        // POWER-UP GEM (NEON GREEN)
        // ============================================
        
        function createPowerUpGem(position, right, up, tunnelDir) {
            if (powerUpGem) {
                destroyPowerUpGem();
            }
            
            // Create tetrahedron (3-sided pyramid)
            powerUpGem = BABYLON.MeshBuilder.CreatePolyhedron('powerUpGem', {
                type: 0, // Tetrahedron
                size: 1.2
            }, scene);
            
            powerUpGem.position = position;
            
            // Create reflective, glowing NEON GREEN material
            const gemMat = new BABYLON.StandardMaterial('gemMat', scene);
            gemMat.diffuseColor = new BABYLON.Color3(0, 1, 0.5);      // Neon green
            gemMat.emissiveColor = new BABYLON.Color3(0, 0.9, 0.4);   // Bright green glow
            gemMat.specularColor = new BABYLON.Color3(1, 1, 1);
            gemMat.specularPower = 128;
            gemMat.alpha = 0.9;
            powerUpGem.material = gemMat;
            
            glowLayer.addIncludedOnlyMesh(powerUpGem);
            
            // Spark particles around gem - NEON GREEN
            gemSparkParticles = new BABYLON.ParticleSystem('gemSparks', 100, scene);
            
            const sparkTex = new BABYLON.DynamicTexture('gemSparkTex', 32, scene);
            const ctx = sparkTex.getContext();
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(100,255,150,1)');
            grad.addColorStop(0.6, 'rgba(0,255,100,0.8)');
            grad.addColorStop(1, 'rgba(0,200,50,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            sparkTex.update();
            
            gemSparkParticles.particleTexture = sparkTex;
            gemSparkParticles.emitter = powerUpGem;
            
            gemSparkParticles.createSphereEmitter(1.5);
            
            gemSparkParticles.color1 = new BABYLON.Color4(1, 1, 1, 1);
            gemSparkParticles.color2 = new BABYLON.Color4(0, 1, 0.5, 1);
            gemSparkParticles.colorDead = new BABYLON.Color4(0, 0.5, 0.2, 0);
            
            gemSparkParticles.minSize = 0.05;
            gemSparkParticles.maxSize = 0.15;
            
            gemSparkParticles.minLifeTime = 0.1;
            gemSparkParticles.maxLifeTime = 0.3;
            gemSparkParticles.emitRate = 50;
            
            gemSparkParticles.direction1 = new BABYLON.Vector3(-2, -2, -2);
            gemSparkParticles.direction2 = new BABYLON.Vector3(2, 2, 2);
            gemSparkParticles.minEmitPower = 3;
            gemSparkParticles.maxEmitPower = 8;
            
            gemSparkParticles.gravity = new BABYLON.Vector3(0, 0, 0);
            gemSparkParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            gemSparkParticles.start();
            
            // Glow particles - NEON GREEN
            gemGlowParticles = new BABYLON.ParticleSystem('gemGlow', 50, scene);
            
            const glowTex = new BABYLON.DynamicTexture('gemGlowTex', 64, scene);
            const glowCtx = glowTex.getContext();
            const glowGrad = glowCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
            glowGrad.addColorStop(0, 'rgba(100,255,150,0.8)');
            glowGrad.addColorStop(0.5, 'rgba(0,200,100,0.4)');
            glowGrad.addColorStop(1, 'rgba(0,100,50,0)');
            glowCtx.fillStyle = glowGrad;
            glowCtx.fillRect(0, 0, 64, 64);
            glowTex.update();
            
            gemGlowParticles.particleTexture = glowTex;
            gemGlowParticles.emitter = powerUpGem;
            
            gemGlowParticles.minEmitBox = new BABYLON.Vector3(-0.3, -0.3, -0.3);
            gemGlowParticles.maxEmitBox = new BABYLON.Vector3(0.3, 0.3, 0.3);
            
            gemGlowParticles.color1 = new BABYLON.Color4(0, 1, 0.5, 0.5);
            gemGlowParticles.color2 = new BABYLON.Color4(0.3, 1, 0.5, 0.3);
            gemGlowParticles.colorDead = new BABYLON.Color4(0, 0.5, 0.2, 0);
            
            gemGlowParticles.minSize = 1.0;
            gemGlowParticles.maxSize = 2.0;
            
            gemGlowParticles.minLifeTime = 0.2;
            gemGlowParticles.maxLifeTime = 0.4;
            gemGlowParticles.emitRate = 30;
            
            gemGlowParticles.minEmitPower = 0.1;
            gemGlowParticles.maxEmitPower = 0.3;
            
            gemGlowParticles.gravity = new BABYLON.Vector3(0, 0, 0);
            gemGlowParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            gemGlowParticles.start();
            
            // Store rotation speed
            powerUpGem.rotationSpeed = new BABYLON.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            );
            
            console.log('üíé Power-up gem created at distance:', Math.floor(gameState.distance), 'spawn ahead:', CONFIG.powerUpSpawnAheadDistance);
        }
        
        function destroyPowerUpGem() {
            if (powerUpGem) {
                glowLayer.removeIncludedOnlyMesh(powerUpGem);
                powerUpGem.dispose();
                powerUpGem = null;
            }
            if (gemSparkParticles) {
                gemSparkParticles.stop();
                gemSparkParticles.dispose();
                gemSparkParticles = null;
            }
            if (gemGlowParticles) {
                gemGlowParticles.stop();
                gemGlowParticles.dispose();
                gemGlowParticles = null;
            }
        }
        
        function triggerGemExplosion(position) {
            // Create a special NEON GREEN explosion for the gem
            const gemExplosion = new BABYLON.ParticleSystem('gemExplosion', 300, scene);
            
            const explosionTex = new BABYLON.DynamicTexture('gemExpTex', 64, scene);
            const ctx = explosionTex.getContext();
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(150,255,180,1)');
            grad.addColorStop(0.5, 'rgba(0,255,100,0.8)');
            grad.addColorStop(1, 'rgba(0,150,50,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            explosionTex.update();
            
            gemExplosion.particleTexture = explosionTex;
            gemExplosion.emitter = position.clone();
            gemExplosion.minEmitBox = new BABYLON.Vector3(-0.5, -0.5, -0.5);
            gemExplosion.maxEmitBox = new BABYLON.Vector3(0.5, 0.5, 0.5);
            
            gemExplosion.color1 = new BABYLON.Color4(1, 1, 1, 1);
            gemExplosion.color2 = new BABYLON.Color4(0, 1, 0.5, 1);
            gemExplosion.colorDead = new BABYLON.Color4(0, 0.8, 0.3, 0);
            
            gemExplosion.minSize = 0.3;
            gemExplosion.maxSize = 1.0;
            gemExplosion.minLifeTime = 0.3;
            gemExplosion.maxLifeTime = 0.8;
            
            gemExplosion.direction1 = new BABYLON.Vector3(-8, -8, -8);
            gemExplosion.direction2 = new BABYLON.Vector3(8, 8, 8);
            gemExplosion.minEmitPower = 15;
            gemExplosion.maxEmitPower = 30;
            
            gemExplosion.gravity = new BABYLON.Vector3(0, 0, 0);
            gemExplosion.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            gemExplosion.targetStopDuration = 0.5;
            gemExplosion.disposeOnStop = true;
            
            gemExplosion.manualEmitCount = 300;
            gemExplosion.start();
        }
        
        function updatePowerUpGem(dt) {
            if (powerUpGem && powerUpGem.rotationSpeed) {
                powerUpGem.rotation.x += powerUpGem.rotationSpeed.x * dt * 0.05;
                powerUpGem.rotation.y += powerUpGem.rotationSpeed.y * dt * 0.05;
                powerUpGem.rotation.z += powerUpGem.rotationSpeed.z * dt * 0.05;
            }
        }
        
        // ============================================
        // INVINCIBILITY SYSTEM
        // ============================================
        
        function activateInvincibility() {
            gameState.isInvincible = true;
            gameState.invincibilityTimeRemaining = CONFIG.invincibilityDuration;
            gameState.invincibilityWindingDown = false;
            gameState.cubesDestroyed = 0;
            gameState.currentMaxSpeed = CONFIG.maxSpeed * CONFIG.speedBoostMultiplier;
            gameState.preBoostSpeed = gameState.speed;
            gameState.powerUpFlashTime = 0;  // NEW: Reset flash timer
            
            startInvincibilityEffects();
            setTrailParticlesToWhite();  // NEW: Change trail colors to white
            
            // Show UI elements
            powerUpGaugeElement.classList.add('active');
            cubesDestroyedElement.classList.add('active');
            
            updateInvincibilityGauge();
            
            console.log('‚ö° Invincibility activated! Duration:', CONFIG.invincibilityDuration, 'seconds');
        }
        
        function deactivateInvincibility() {
            gameState.isInvincible = false;
            gameState.invincibilityTimeRemaining = 0;
            gameState.invincibilityWindingDown = false;
            gameState.isDecelerating = false;
            gameState.currentMaxSpeed = CONFIG.maxSpeed;
            
            stopInvincibilityEffects();
            setTrailParticlesToNormal();  // NEW: Restore trail colors
            resetCubeColors();            // NEW: Reset cube colors
            
            // Hide UI elements
            powerUpGaugeElement.classList.remove('active');
            cubesDestroyedElement.classList.remove('active');
            
            console.log('‚ö° Invincibility ended! Cubes destroyed:', gameState.cubesDestroyed);
        }
        
        function updateInvincibilityGauge() {
            const percentage = Math.max(0, (gameState.invincibilityTimeRemaining / CONFIG.invincibilityDuration) * 100);
            const angle = (percentage / 100) * 360;
            
            // Update the gauge fill using conic-gradient
            gaugeFillElement.style.background = `conic-gradient(
                from -90deg,
                #ffffff 0deg,
                #ffff88 ${angle * 0.25}deg,
                #ffff00 ${angle * 0.5}deg,
                #ffaa00 ${angle * 0.75}deg,
                #ff8800 ${angle}deg,
                transparent ${angle}deg
            )`;
            
            // Update time display
            const displayTime = Math.max(0, gameState.invincibilityTimeRemaining);
            gaugeTimeElement.textContent = displayTime.toFixed(1) + 's';
            
            // Update destroyed count
            destroyedCountElement.textContent = gameState.cubesDestroyed;
        }
        
        function boostSpeed() {
            const targetSpeed = Math.min(gameState.speed * CONFIG.speedBoostMultiplier, gameState.currentMaxSpeed);
            gameState.speed = targetSpeed;
            gameState.speedBoostTimer = CONFIG.speedBoostHoldTime;
            
            console.log('üöÄ Speed boosted to:', gameState.speed.toFixed(2));
        }
        
        function updateSpeedBoost(dt) {
            const deltaSeconds = dt / 60;
            
            if (gameState.isInvincible) {
                // Update invincibility timer
                if (gameState.invincibilityTimeRemaining > 0) {
                    gameState.invincibilityTimeRemaining -= deltaSeconds;
                }
                
                // Update flash timer for warning effect
                gameState.powerUpFlashTime += deltaSeconds;
                
                // NEW: Ball color alternation warning (3 seconds before expiry)
                if (gameState.invincibilityTimeRemaining <= CONFIG.powerUpWarningTime && 
                    gameState.invincibilityTimeRemaining > 0 && 
                    !gameState.invincibilityWindingDown) {
                    
                    // Use sine wave to alternate between colors
                    const flashPhase = Math.sin(gameState.powerUpFlashTime * Math.PI * CONFIG.ballFlashSpeed);
                    const showNormalColor = flashPhase > 0;
                    
                    if (ballMaterial) {
                        if (showNormalColor) {
                            // Normal green color
                            ballMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.9, 0.4);
                            ballMaterial.emissiveColor = new BABYLON.Color3(0.08, 0.5, 0.25);
                        } else {
                            // Power-up white color
                            ballMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                            ballMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
                        }
                    }
                }
                
                // Check if timer expired and we need to start wind-down
                if (gameState.invincibilityTimeRemaining <= 0 && !gameState.invincibilityWindingDown) {
                    gameState.invincibilityWindingDown = true;
                    gameState.invincibilityTimeRemaining = 0;
                    console.log('‚è≥ Invincibility winding down - decelerating to normal speed');
                }
                
                // Handle speed boost timer
                if (gameState.speedBoostTimer > 0) {
                    gameState.speedBoostTimer -= deltaSeconds;
                }
                
                // If winding down, decelerate back to normal max speed
                if (gameState.invincibilityWindingDown) {
                    if (gameState.speed > CONFIG.maxSpeed) {
                        const decelRate = (gameState.preBoostSpeed * CONFIG.speedBoostMultiplier - CONFIG.maxSpeed) / CONFIG.speedDecelerationTime;
                        gameState.speed = Math.max(CONFIG.maxSpeed, gameState.speed - decelRate * deltaSeconds);
                        
                        // Also transition ball color back gradually
                        const progress = (gameState.speed - CONFIG.maxSpeed) / ((gameState.preBoostSpeed * CONFIG.speedBoostMultiplier) - CONFIG.maxSpeed);
                        if (ballMaterial) {
                            // Interpolate from white back to green
                            const r = 0.1 + (1 - 0.1) * progress;
                            const g = 0.9 + (1 - 0.9) * progress;
                            const b = 0.4 + (1 - 0.4) * progress;
                            ballMaterial.diffuseColor = new BABYLON.Color3(r, g, b);
                            
                            const er = 0.08 + (1 - 0.08) * progress;
                            const eg = 0.5 + (1 - 0.5) * progress;
                            const eb = 0.25 + (1 - 0.25) * progress;
                            ballMaterial.emissiveColor = new BABYLON.Color3(er, eg, eb);
                        }
                    } else {
                        // Speed is back to normal, fully deactivate invincibility
                        deactivateInvincibility();
                    }
                } else if (gameState.speedBoostTimer <= 0 && gameState.speed > CONFIG.maxSpeed) {
                    // Normal invincibility idle - slowly decelerate towards normal max speed
                    const decelRate = (gameState.speed - CONFIG.maxSpeed) / CONFIG.speedDecelerationTime;
                    gameState.speed = Math.max(CONFIG.maxSpeed, gameState.speed - decelRate * deltaSeconds);
                }
                
                updateInvincibilityGauge();
            }
        }
        
        function updateTrailParticles(tunnelDir, speed) {
            const speedMultiplier = speed / CONFIG.baseSpeed;
            
            if (fireTrailParticles) {
                fireTrailParticles.emitRate = 150 * speedMultiplier;
                fireTrailParticles.minEmitPower = 3 * speedMultiplier;
                fireTrailParticles.maxEmitPower = 6 * speedMultiplier;
                
                const backDir = tunnelDir.scale(-1);
                fireTrailParticles.direction1 = new BABYLON.Vector3(
                    backDir.x - 0.3, backDir.y - 0.3, backDir.z + 0.3
                );
                fireTrailParticles.direction2 = new BABYLON.Vector3(
                    backDir.x + 0.3, backDir.y + 0.3, backDir.z + 1.0
                );
            }
            
            if (smokeTrailParticles) {
                smokeTrailParticles.emitRate = 60 * speedMultiplier;
                
                const backDir = tunnelDir.scale(-0.5);
                smokeTrailParticles.direction1 = new BABYLON.Vector3(
                    backDir.x - 0.5, backDir.y - 0.3, backDir.z + 0.2
                );
                smokeTrailParticles.direction2 = new BABYLON.Vector3(
                    backDir.x + 0.5, backDir.y + 0.5, backDir.z + 0.8
                );
            }
            
            if (sparkTrailParticles) {
                sparkTrailParticles.emitRate = 40 * speedMultiplier;
                sparkTrailParticles.minEmitPower = 4 * speedMultiplier;
                sparkTrailParticles.maxEmitPower = 10 * speedMultiplier;
            }
            
            if (coreGlowParticles) {
                coreGlowParticles.emitRate = 60 * speedMultiplier;
            }
        }
        
        function stopTrailParticles() {
            if (fireTrailParticles) fireTrailParticles.stop();
            if (smokeTrailParticles) smokeTrailParticles.stop();
            if (sparkTrailParticles) sparkTrailParticles.stop();
            if (coreGlowParticles) coreGlowParticles.stop();
        }
        
        function startTrailParticles() {
            if (fireTrailParticles) fireTrailParticles.start();
            if (smokeTrailParticles) smokeTrailParticles.start();
            if (sparkTrailParticles) sparkTrailParticles.start();
            if (coreGlowParticles) coreGlowParticles.start();
        }

        function createExplosionParticles() {
            explosionParticles = new BABYLON.ParticleSystem('explosion', CONFIG.explosionParticles, scene);
            
            const particleTexture = new BABYLON.DynamicTexture('particleTex', 64, scene);
            const ctx = particleTexture.getContext();
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,200,100,1)');
            gradient.addColorStop(0.7, 'rgba(255,100,50,0.5)');
            gradient.addColorStop(1, 'rgba(255,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            particleTexture.update();
            
            explosionParticles.particleTexture = particleTexture;
            explosionParticles.emitter = new BABYLON.Vector3(0, 0, 0);
            explosionParticles.minEmitBox = new BABYLON.Vector3(-0.3, -0.3, -0.3);
            explosionParticles.maxEmitBox = new BABYLON.Vector3(0.3, 0.3, 0.3);
            
            explosionParticles.color1 = new BABYLON.Color4(1, 0.8, 0.2, 1);
            explosionParticles.color2 = new BABYLON.Color4(1, 0.2, 0, 1);
            explosionParticles.colorDead = new BABYLON.Color4(0.3, 0, 0, 0);
            
            explosionParticles.minSize = 0.3;
            explosionParticles.maxSize = 1.0;
            explosionParticles.minLifeTime = 0.2;
            explosionParticles.maxLifeTime = 0.8;
            explosionParticles.emitRate = 0;
            explosionParticles.manualEmitCount = 0;
            explosionParticles.direction1 = new BABYLON.Vector3(-5, -5, -5);
            explosionParticles.direction2 = new BABYLON.Vector3(5, 5, 5);
            explosionParticles.minEmitPower = 8;
            explosionParticles.maxEmitPower = 20;
            explosionParticles.gravity = new BABYLON.Vector3(0, -8, 0);
            explosionParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            explosionParticles.start();
        }

        function generateDramaticEvent() {
            const eventType = Math.random();
            
            if (eventType < 0.4) {
                return {
                    angleHChange: (Math.random() - 0.5) * 0.2,
                    angleVChange: CONFIG.dramaticDropStrength * (0.5 + Math.random() * 0.5)
                };
            } else if (eventType < 0.7) {
                return {
                    angleHChange: (Math.random() - 0.5) * 0.2,
                    angleVChange: -CONFIG.dramaticDropStrength * (0.3 + Math.random() * 0.4)
                };
            } else if (eventType < 0.85) {
                return {
                    angleHChange: -CONFIG.dramaticCurveStrength * (0.5 + Math.random() * 0.5),
                    angleVChange: (Math.random() - 0.5) * 0.2
                };
            } else {
                return {
                    angleHChange: CONFIG.dramaticCurveStrength * (0.5 + Math.random() * 0.5),
                    angleVChange: (Math.random() - 0.5) * 0.2
                };
            }
        }

        function catmullRomSpline(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            
            return {
                x: 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                y: 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3),
                z: 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)
            };
        }

        function generateSmoothPath() {
            gameState.smoothedPath = [];
            const controlPoints = gameState.tunnelPath;
            
            if (controlPoints.length < 4) return;
            
            for (let i = 0; i < controlPoints.length - 1; i++) {
                const p0 = controlPoints[Math.max(0, i - 1)];
                const p1 = controlPoints[i];
                const p2 = controlPoints[Math.min(controlPoints.length - 1, i + 1)];
                const p3 = controlPoints[Math.min(controlPoints.length - 1, i + 2)];
                
                const subdivisions = CONFIG.pathSubdivisions;
                for (let j = 0; j < subdivisions; j++) {
                    const t = j / subdivisions;
                    const point = catmullRomSpline(p0, p1, p2, p3, t);
                    point.segmentIndex = i;
                    point.localT = t;
                    gameState.smoothedPath.push(point);
                }
            }
            
            const lastPoint = controlPoints[controlPoints.length - 1];
            gameState.smoothedPath.push({
                x: lastPoint.x,
                y: lastPoint.y,
                z: lastPoint.z,
                segmentIndex: controlPoints.length - 1,
                localT: 0
            });
        }

        function getSmoothPathData(distance) {
            const totalSegmentLength = CONFIG.tunnelSegmentLength;
            const smoothPointsPerSegment = CONFIG.pathSubdivisions;
            const smoothPointLength = totalSegmentLength / smoothPointsPerSegment;
            
            const smoothIndex = distance / smoothPointLength;
            const baseIndex = Math.floor(smoothIndex);
            const t = smoothIndex - baseIndex;
            
            if (baseIndex < 0 || baseIndex >= gameState.smoothedPath.length - 1) {
                const segIndex = Math.floor(distance / totalSegmentLength);
                const segT = (distance % totalSegmentLength) / totalSegmentLength;
                const pathIndex = segIndex + CONFIG.tunnelSegmentsBehind;
                
                if (pathIndex >= 0 && pathIndex < gameState.tunnelPath.length - 1) {
                    const p1 = gameState.tunnelPath[pathIndex];
                    const p2 = gameState.tunnelPath[pathIndex + 1];
                    return {
                        position: new BABYLON.Vector3(
                            p1.x + (p2.x - p1.x) * segT,
                            p1.y + (p2.y - p1.y) * segT,
                            p1.z + (p2.z - p1.z) * segT
                        ),
                        direction: new BABYLON.Vector3(
                            p2.x - p1.x,
                            p2.y - p1.y,
                            p2.z - p1.z
                        ).normalize()
                    };
                }
                return null;
            }
            
            const p1 = gameState.smoothedPath[baseIndex];
            const p2 = gameState.smoothedPath[Math.min(baseIndex + 1, gameState.smoothedPath.length - 1)];
            const p3 = gameState.smoothedPath[Math.min(baseIndex + 2, gameState.smoothedPath.length - 1)];
            
            const position = new BABYLON.Vector3(
                p1.x + (p2.x - p1.x) * t,
                p1.y + (p2.y - p1.y) * t,
                p1.z + (p2.z - p1.z) * t
            );
            
            const direction = new BABYLON.Vector3(
                p3.x - p1.x,
                p3.y - p1.y,
                p3.z - p1.z
            ).normalize();
            
            return { position, direction };
        }

        function initializeTunnelPath() {
            gameState.tunnelPath = [];
            let currentPos = { x: 0, y: 0, z: 0 };
            let currentAngleH = 0;
            let currentAngleV = 0;
            
            for (let i = 0; i < CONFIG.tunnelSegmentsAhead + CONFIG.tunnelSegmentsBehind + 100; i++) {
                gameState.tunnelPath.push({ 
                    x: currentPos.x, 
                    y: currentPos.y, 
                    z: currentPos.z,
                    angleH: currentAngleH,
                    angleV: currentAngleV
                });
                
                currentPos.z += CONFIG.tunnelSegmentLength * Math.cos(currentAngleH) * Math.cos(currentAngleV);
                currentPos.x += CONFIG.tunnelSegmentLength * Math.sin(currentAngleH);
                currentPos.y += CONFIG.tunnelSegmentLength * Math.sin(currentAngleV);
                
                if (i > 5) {
                    if (Math.random() < CONFIG.dramaticEventChance) {
                        const event = generateDramaticEvent();
                        currentAngleH += event.angleHChange;
                        currentAngleV += event.angleVChange;
                    } else {
                        currentAngleH += (Math.random() - 0.5) * CONFIG.tunnelBendHorizontal;
                        currentAngleV += (Math.random() - 0.5) * CONFIG.tunnelBendVertical;
                    }
                    
                    currentAngleH = Math.max(-CONFIG.tunnelMaxAngleH, Math.min(CONFIG.tunnelMaxAngleH, currentAngleH));
                    currentAngleV = Math.max(-CONFIG.tunnelMaxAngleV, Math.min(CONFIG.tunnelMaxAngleV, currentAngleV));
                    
                    currentAngleH *= 0.95;
                    currentAngleV *= 0.92;
                }
            }
            
            generateSmoothPath();
        }

        function extendTunnelPath() {
            const lastPoint = gameState.tunnelPath[gameState.tunnelPath.length - 1];
            
            let angleH, angleV;
            
            if (Math.random() < CONFIG.dramaticEventChance) {
                const event = generateDramaticEvent();
                angleH = lastPoint.angleH + event.angleHChange;
                angleV = lastPoint.angleV + event.angleVChange;
            } else {
                angleH = lastPoint.angleH + (Math.random() - 0.5) * CONFIG.tunnelBendHorizontal;
                angleV = lastPoint.angleV + (Math.random() - 0.5) * CONFIG.tunnelBendVertical;
            }
            
            angleH = Math.max(-CONFIG.tunnelMaxAngleH, Math.min(CONFIG.tunnelMaxAngleH, angleH));
            angleV = Math.max(-CONFIG.tunnelMaxAngleV, Math.min(CONFIG.tunnelMaxAngleV, angleV));
            
            angleH *= 0.95;
            angleV *= 0.92;
            
            const newPoint = {
                x: lastPoint.x + CONFIG.tunnelSegmentLength * Math.sin(angleH),
                y: lastPoint.y + CONFIG.tunnelSegmentLength * Math.sin(angleV),
                z: lastPoint.z + CONFIG.tunnelSegmentLength * Math.cos(angleH) * Math.cos(angleV),
                angleH: angleH,
                angleV: angleV
            };
            
            gameState.tunnelPath.push(newPoint);
            generateSmoothPath();
        }

        function getRotationBetweenVectors(from, to) {
            const dot = BABYLON.Vector3.Dot(from, to);
            
            if (dot > 0.9999) {
                return BABYLON.Quaternion.Identity();
            }
            
            if (dot < -0.9999) {
                let perpendicular = BABYLON.Vector3.Cross(from, BABYLON.Axis.X);
                if (perpendicular.length() < 0.001) {
                    perpendicular = BABYLON.Vector3.Cross(from, BABYLON.Axis.Z);
                }
                perpendicular.normalize();
                return BABYLON.Quaternion.RotationAxis(perpendicular, Math.PI);
            }
            
            const axis = BABYLON.Vector3.Cross(from, to);
            axis.normalize();
            const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
            
            return BABYLON.Quaternion.RotationAxis(axis, angle);
        }

        function createTunnelSegment(segmentIndex) {
            const pathIndex = segmentIndex + CONFIG.tunnelSegmentsBehind;
            
            if (pathIndex < 0 || pathIndex >= gameState.tunnelPath.length - 1) return null;
            
            const p0 = gameState.tunnelPath[Math.max(0, pathIndex - 1)];
            const p1 = gameState.tunnelPath[pathIndex];
            const p2 = gameState.tunnelPath[pathIndex + 1];
            const p3 = gameState.tunnelPath[Math.min(gameState.tunnelPath.length - 1, pathIndex + 2)];
            
            const segmentGroup = { meshes: [], obstacles: [], index: segmentIndex, pathIndex: pathIndex };
            
            const pathPoints = [];
            const numPoints = CONFIG.pathSubdivisions;
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const point = catmullRomSpline(p0, p1, p2, p3, t);
                pathPoints.push(new BABYLON.Vector3(point.x, point.y, point.z));
            }
            
            const midPoint = catmullRomSpline(p0, p1, p2, p3, 0.5);
            const midPointNext = catmullRomSpline(p0, p1, p2, p3, 0.52);
            const dir = new BABYLON.Vector3(
                midPointNext.x - midPoint.x,
                midPointNext.y - midPoint.y,
                midPointNext.z - midPoint.z
            ).normalize();
            
            const tube = BABYLON.MeshBuilder.CreateTube('tunnel_' + segmentIndex, {
                path: pathPoints,
                radius: CONFIG.tunnelRadius,
                tessellation: 48,
                sideOrientation: BABYLON.Mesh.BACKSIDE,
                updatable: false,
                cap: BABYLON.Mesh.NO_CAP
            }, scene);
            
            const tubeMat = new BABYLON.StandardMaterial('tubeMat_' + segmentIndex, scene);
            const hue = ((segmentIndex * 12) % 360);
            const color = BABYLON.Color3.FromHSV(hue, 0.5, 0.4);
            tubeMat.diffuseColor = color;
            tubeMat.emissiveColor = color.scale(0.15);
            tubeMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            tube.material = tubeMat;
            
            segmentGroup.meshes.push(tube);
            
            const numRings = 5;
            for (let r = 0; r < numRings; r++) {
                const t = (r + 0.5) / numRings;
                const ringPoint = catmullRomSpline(p0, p1, p2, p3, t);
                const ringPointNext = catmullRomSpline(p0, p1, p2, p3, Math.min(1, t + 0.05));
                
                const ringPos = new BABYLON.Vector3(ringPoint.x, ringPoint.y, ringPoint.z);
                const ringDir = new BABYLON.Vector3(
                    ringPointNext.x - ringPoint.x,
                    ringPointNext.y - ringPoint.y,
                    ringPointNext.z - ringPoint.z
                ).normalize();
                
                const ring = BABYLON.MeshBuilder.CreateTorus('ring_' + segmentIndex + '_' + r, {
                    diameter: CONFIG.tunnelRadius * 2 - 0.15,
                    thickness: 0.12,
                    tessellation: 48
                }, scene);
                
                ring.position = ringPos;
                
                const baseRotation = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.X, Math.PI / 2);
                const alignRotation = getRotationBetweenVectors(BABYLON.Axis.Z, ringDir);
                ring.rotationQuaternion = alignRotation.multiply(baseRotation);
                
                const ringMat = new BABYLON.StandardMaterial('ringMat_' + segmentIndex + '_' + r, scene);
                const ringHue = ((segmentIndex * 12 + r * 15 + 180) % 360);
                const ringColor = BABYLON.Color3.FromHSV(ringHue, 0.9, 1.0);
                ringMat.diffuseColor = ringColor;
                ringMat.emissiveColor = ringColor.scale(0.7);
                ring.material = ringMat;
                
                glowLayer.addIncludedOnlyMesh(ring);
                segmentGroup.meshes.push(ring);
            }
            
            const numGuideLines = 8;
            const guideStartT = CONFIG.guideLineStartT;
            const guideEndT = CONFIG.guideLineEndT;
            const guideNumPoints = Math.floor(numPoints * (guideEndT - guideStartT));
            
            for (let g = 0; g < numGuideLines; g++) {
                const guideAngle = (g / numGuideLines) * Math.PI * 2;
                
                const guidePoints = [];
                for (let i = 0; i <= guideNumPoints; i++) {
                    const t = guideStartT + (i / guideNumPoints) * (guideEndT - guideStartT);
                    const point = catmullRomSpline(p0, p1, p2, p3, t);
                    const pointNext = catmullRomSpline(p0, p1, p2, p3, Math.min(1, t + 0.02));
                    
                    const centerPos = new BABYLON.Vector3(point.x, point.y, point.z);
                    const localDir = new BABYLON.Vector3(
                        pointNext.x - point.x,
                        pointNext.y - point.y,
                        pointNext.z - point.z
                    ).normalize();
                    
                    let right = BABYLON.Vector3.Cross(localDir, BABYLON.Axis.Y);
                    if (right.length() < 0.001) {
                        right = BABYLON.Vector3.Cross(localDir, BABYLON.Axis.X);
                    }
                    right.normalize();
                    const up = BABYLON.Vector3.Cross(right, localDir).normalize();
                    
                    const guideRadius = CONFIG.tunnelRadius - 0.15;
                    const offset = right.scale(Math.sin(guideAngle) * guideRadius)
                        .add(up.scale(Math.cos(guideAngle) * guideRadius));
                    
                    guidePoints.push(centerPos.add(offset));
                }
                
                if (guidePoints.length >= 2) {
                    const guideLine = BABYLON.MeshBuilder.CreateTube('guide_' + segmentIndex + '_' + g, {
                        path: guidePoints,
                        radius: 0.04,
                        tessellation: 8,
                        updatable: false,
                        cap: BABYLON.Mesh.NO_CAP
                    }, scene);
                    
                    const guideMat = new BABYLON.StandardMaterial('guideMat_' + segmentIndex + '_' + g, scene);
                    const guideHue = ((segmentIndex * 12 + g * 45) % 360);
                    guideMat.emissiveColor = BABYLON.Color3.FromHSV(guideHue, 0.6, 0.35);
                    guideMat.diffuseColor = BABYLON.Color3.FromHSV(guideHue, 0.6, 0.25);
                    guideLine.material = guideMat;
                    
                    segmentGroup.meshes.push(guideLine);
                }
            }
            
            if (segmentIndex > 3 && Math.random() < CONFIG.obstacleFrequency) {
                const numObstacles = CONFIG.minObstaclesPerSegment + 
                    Math.floor(Math.random() * (CONFIG.maxObstaclesPerSegment - CONFIG.minObstaclesPerSegment + 1));
                
                for (let o = 0; o < numObstacles; o++) {
                    createObstacle(segmentGroup, p0, p1, p2, p3, segmentIndex, o);
                }
            }
            
            tunnelSegments.push(segmentGroup);
            return segmentGroup;
        }

        function createObstacle(segmentGroup, p0, p1, p2, p3, segmentIndex, obstacleIndex) {
            const t = 0.1 + Math.random() * 0.8;
            const point = catmullRomSpline(p0, p1, p2, p3, t);
            const pointNext = catmullRomSpline(p0, p1, p2, p3, Math.min(1, t + 0.02));
            
            const basePos = new BABYLON.Vector3(point.x, point.y, point.z);
            const dir = new BABYLON.Vector3(
                pointNext.x - point.x,
                pointNext.y - point.y,
                pointNext.z - point.z
            ).normalize();
            
            let right = BABYLON.Vector3.Cross(dir, BABYLON.Axis.Y);
            if (right.length() < 0.001) {
                right = BABYLON.Vector3.Cross(dir, BABYLON.Axis.X);
            }
            right.normalize();
            const up = BABYLON.Vector3.Cross(right, dir).normalize();
            
            const obstacleAngle = Math.random() * Math.PI * 2;
            const obstacleRadius = CONFIG.tunnelRadius - 0.8 - Math.random() * 0.8;
            
            const cubeSize = 1.6 + Math.random() * 1.2;
            const cube = BABYLON.MeshBuilder.CreateBox('obstacle_' + segmentIndex + '_' + obstacleIndex, { 
                size: cubeSize 
            }, scene);
            
            const offset = right.scale(Math.sin(obstacleAngle) * obstacleRadius)
                .add(up.scale(Math.cos(obstacleAngle) * obstacleRadius));
            
            cube.position = basePos.add(offset);
            cube.rotation = new BABYLON.Vector3(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            const currentColor = gameState.currentObstacleColor;
            const cubeMat = new BABYLON.StandardMaterial('obsMat_' + segmentIndex + '_' + obstacleIndex, scene);
            cubeMat.diffuseColor = currentColor.color.clone();
            cubeMat.emissiveColor = currentColor.emissive.clone();
            cubeMat.specularColor = currentColor.color.scale(0.5).add(new BABYLON.Color3(0.5, 0.5, 0.5));
            cube.material = cubeMat;
            
            glowLayer.addIncludedOnlyMesh(cube);
            
            cube.cubeSize = cubeSize;
            cube.obstacleAngle = obstacleAngle;
            cube.obstacleT = t;
            cube.obstacleRadius = obstacleRadius;
            
            segmentGroup.meshes.push(cube);
            segmentGroup.obstacles.push(cube);
            obstacles.push(cube);
        }

        function removeTunnelSegment(segmentGroup) {
            if (!segmentGroup) return;
            
            segmentGroup.meshes.forEach(mesh => {
                if (mesh && !mesh.isDisposed()) {
                    glowLayer.removeIncludedOnlyMesh(mesh);
                    mesh.dispose();
                }
            });
            
            segmentGroup.obstacles.forEach(obs => {
                const idx = obstacles.indexOf(obs);
                if (idx > -1) obstacles.splice(idx, 1);
            });
        }
        
        function checkAndUpdateObstacleColor() {
            const currentDistance = Math.floor(gameState.distance);
            const interval = CONFIG.obstacleColorChangeInterval;
            
            const currentMilestone = Math.floor(currentDistance / interval) * interval;
            
            if (currentMilestone > gameState.lastColorChangeDistance && currentMilestone >= interval) {
                const previousIndex = gameState.currentObstacleColor.index;
                const newColor = generateRandomNeonColor(previousIndex);
                gameState.currentObstacleColor = newColor;
                gameState.lastColorChangeDistance = currentMilestone;
                
                console.log(`üé® Color changed at ${currentMilestone}m: ${newColor.name}`);
            }
        }
        
        // ============================================
        // POWER-UP GEM SPAWNING (LOWER HALF ONLY)
        // ============================================
        
        function checkAndSpawnPowerUpGem() {
            // Don't spawn if there's already a gem or player is invincible
            if (powerUpGem || gameState.isInvincible) return;
            
            // Check if we've reached the next gem distance
            if (gameState.distance >= gameState.nextGemDistance) {
                // Spawn gem much further ahead (350+ units ahead)
                const gemDistance = gameState.distance + CONFIG.powerUpSpawnAheadDistance + Math.random() * 100;
                const pathData = getSmoothPathData(gemDistance);
                
                if (pathData) {
                    const tunnelCenter = pathData.position;
                    const tunnelDir = pathData.direction;
                    
                    let right = BABYLON.Vector3.Cross(tunnelDir, BABYLON.Axis.Y);
                    if (right.length() < 0.001) {
                        right = BABYLON.Vector3.Cross(tunnelDir, BABYLON.Axis.X);
                    }
                    right.normalize();
                    const up = BABYLON.Vector3.Cross(right, tunnelDir).normalize();
                    
                    // Place gem on tunnel wall - LOWER HALF ONLY
                    // Lower half is from œÄ/2 to 3œÄ/2 (angles where the "up" component is negative or zero)
                    const gemAngle = (Math.PI / 2) + Math.random() * Math.PI;  // Range: [œÄ/2, 3œÄ/2]
                    const gemRadius = CONFIG.tunnelRadius - 2;
                    
                    const offset = right.scale(Math.sin(gemAngle) * gemRadius)
                        .add(up.scale(Math.cos(gemAngle) * gemRadius));
                    
                    const gemPosition = tunnelCenter.add(offset);
                    
                    createPowerUpGem(gemPosition, right, up, tunnelDir);
                    
                    // Set next gem spawn distance
                    gameState.nextGemDistance = gameState.distance + 
                        CONFIG.powerUpMinDistance + 
                        Math.random() * (CONFIG.powerUpMaxDistance - CONFIG.powerUpMinDistance);
                        
                    console.log('üíé Next gem will spawn at distance:', Math.floor(gameState.nextGemDistance));
                }
            }
        }
        
        function updatePowerUpGemPosition() {
            // Remove gem if it's too far behind the player
            if (powerUpGem) {
                const gemZ = powerUpGem.position.z;
                const ballZ = ball.position.z;
                
                if (gemZ < ballZ - 50) {
                    destroyPowerUpGem();
                    console.log('üíé Power-up gem passed - setting new spawn distance');
                    gameState.nextGemDistance = gameState.distance + 
                        CONFIG.powerUpMinDistance + 
                        Math.random() * (CONFIG.powerUpMaxDistance - CONFIG.powerUpMinDistance);
                }
            }
        }

        function handleKeyDown(event) {
            if (event.code === 'Digit0' || event.code === 'Numpad0') {
                resetHighScore();
                return;
            }
            
            if (event.code === 'Escape') {
                event.preventDefault();
                if (gameState.isRunning && !gameState.isGameOver && !gameState.isPaused) {
                    if (!isInFullscreen()) {
                        pauseGame();
                    }
                }
                return;
            }
            
            // Space or Up Arrow for menu actions
            if (event.code === 'Space' || event.code === 'ArrowUp') {
                if (gameState.isPaused) {
                    resumeGame();
                    event.preventDefault();
                    return;
                }
                
                if (highScoreCelebration.style.display === 'block') {
                    continueToProceed();
                    event.preventDefault();
                    return;
                }
                
                if (gameState.isGameOver && gameOverElement.style.display === 'block') {
                    restartGame();
                    event.preventDefault();
                    return;
                }
            }
            
            if (gameState.isGameOver || gameState.isPaused) return;
            
            switch(event.code) {
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = true;
                    event.preventDefault();
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = true;
                    event.preventDefault();
                    break;
                case 'Space':
                case 'ArrowUp':
                    keys.jump = true;
                    event.preventDefault();
                    break;
            }
        }
        
        function handleKeyUp(event) {
            switch(event.code) {
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'Space':
                case 'ArrowUp':
                    keys.jump = false;
                    break;
            }
        }

        function updateGame() {
            const dt = Math.min(engine.getDeltaTime() / 1000, 0.05) * 60;
            
            gameState.gameplayTime += dt / 60;
            
            if (!gameState.instructionsDismissed && gameState.gameplayTime >= 5) {
                gameState.instructionsDismissed = true;
                instructionsShownThisSession = true;
                
                const desktopInstructions = document.querySelector('#instructions.desktop-only');
                const mobileInstructions = document.querySelector('#instructions.mobile-only');
                
                if (isMobile && mobileInstructions) {
                    mobileInstructions.style.opacity = '0';
                    setTimeout(() => {
                        mobileInstructions.style.display = 'none';
                    }, 500);
                } else if (!isMobile && desktopInstructions) {
                    desktopInstructions.style.opacity = '0';
                    setTimeout(() => {
                        desktopInstructions.style.display = 'none';
                    }, 500);
                }
                
                const tiltIndicator = document.getElementById('tiltIndicator');
                if (tiltIndicator && isMobile) {
                    setTimeout(() => {
                        tiltIndicator.style.opacity = '0';
                        tiltIndicator.style.transition = 'opacity 0.5s';
                    }, 2000);
                }
            }
            
            // Update speed (only if not invincible and not decelerating)
            if (!gameState.isInvincible) {
                gameState.speed = Math.min(CONFIG.maxSpeed, gameState.speed + CONFIG.speedIncrement * dt);
            }
            
            // Update speed boost mechanics (handles invincibility timer too)
            updateSpeedBoost(dt);
            
            // NEW: Update cube flashing effect when invincible
            updateCubeFlashing();
            
            gameState.distance += gameState.speed * dt;
            
            checkAndUpdateObstacleColor();
            
            // Check for power-up gem spawning
            checkAndSpawnPowerUpGem();
            updatePowerUpGemPosition();
            updatePowerUpGem(dt);
            
            const segmentIndex = Math.floor(gameState.distance / CONFIG.tunnelSegmentLength);
            const segmentT = (gameState.distance % CONFIG.tunnelSegmentLength) / CONFIG.tunnelSegmentLength;
            const pathIndex = segmentIndex + CONFIG.tunnelSegmentsBehind;
            
            while (gameState.tunnelPath.length < pathIndex + CONFIG.tunnelSegmentsAhead + 10) {
                extendTunnelPath();
            }
            
            if (pathIndex >= 0 && pathIndex < gameState.tunnelPath.length - 1) {
                const pathData = getSmoothPathData(gameState.distance);
                
                if (!pathData) return;
                
                const tunnelCenter = pathData.position;
                const tunnelDir = pathData.direction;
                
                gameState.currentTunnelDir = tunnelDir.clone();
                
                let right = BABYLON.Vector3.Cross(tunnelDir, BABYLON.Axis.Y);
                if (right.length() < 0.001) {
                    right = BABYLON.Vector3.Cross(tunnelDir, BABYLON.Axis.X);
                }
                right.normalize();
                const up = BABYLON.Vector3.Cross(right, tunnelDir).normalize();
                
                if (isMobile && accelerometerEnabled) {
                    const clampedGamma = Math.max(-CONFIG.tiltMaxAngle, Math.min(CONFIG.tiltMaxAngle, deviceGamma));
                    
                    if (Math.abs(clampedGamma) > CONFIG.tiltDeadzone) {
                        const tiltInput = clampedGamma * CONFIG.tiltSensitivity * dt;
                        gameState.angularVelocity += tiltInput;
                    }
                } else {
                    if (keys.left) {
                        gameState.angularVelocity -= CONFIG.angularAcceleration * dt;
                    }
                    if (keys.right) {
                        gameState.angularVelocity += CONFIG.angularAcceleration * dt;
                    }
                }
                
                if (gameState.isGrounded) {
                    const gravityForce = CONFIG.angularGravity * Math.sin(gameState.theta) * dt;
                    gameState.angularVelocity += gravityForce;
                }
                
                if (isMobile && accelerometerEnabled) {
                    if (Math.abs(deviceGamma) <= CONFIG.tiltDeadzone) {
                        gameState.angularVelocity *= Math.pow(CONFIG.angularFriction, 1.5);
                    } else {
                        gameState.angularVelocity *= CONFIG.angularFriction;
                    }
                } else {
                    if (!keys.left && !keys.right) {
                        gameState.angularVelocity *= CONFIG.angularFriction;
                    }
                }
                
                gameState.angularVelocity = Math.max(-CONFIG.angularMaxSpeed, 
                    Math.min(CONFIG.angularMaxSpeed, gameState.angularVelocity));
                
                gameState.theta += gameState.angularVelocity * dt;
                
                while (gameState.theta < 0) gameState.theta += Math.PI * 2;
                while (gameState.theta >= Math.PI * 2) gameState.theta -= Math.PI * 2;
                
                const surfaceRadius = CONFIG.tunnelRadius - CONFIG.ballRadius;
                
                if (keys.jump && gameState.isGrounded) {
                    gameState.radialVelocity = -CONFIG.jumpForce;
                    gameState.isGrounded = false;
                    keys.jump = false;
                }
                
                if (!gameState.isGrounded) {
                    gameState.radialVelocity += CONFIG.radialGravity * dt;
                }
                
                gameState.radialPosition += gameState.radialVelocity * dt;
                
                if (gameState.radialPosition >= surfaceRadius) {
                    gameState.radialPosition = surfaceRadius;
                    gameState.radialVelocity = 0;
                    gameState.isGrounded = true;
                }
                
                if (gameState.radialPosition < CONFIG.ballRadius) {
                    gameState.radialPosition = CONFIG.ballRadius;
                    gameState.radialVelocity = Math.abs(gameState.radialVelocity) * 0.5;
                }
                
                const localX = Math.sin(gameState.theta) * gameState.radialPosition;
                const localY = Math.cos(gameState.theta) * gameState.radialPosition;
                
                const ballWorldPos = tunnelCenter
                    .add(right.scale(localX))
                    .add(up.scale(localY))
                    .subtract(tunnelDir.scale(CONFIG.ballXOffset));
                
                const ballToCenter = tunnelCenter.subtract(ballWorldPos.add(tunnelDir.scale(CONFIG.ballXOffset)));
                const distanceFromCenter = ballToCenter.length();
                
                const minDistanceFromCenter = CONFIG.ballRadius + 0.1;
                const maxDistanceFromCenter = CONFIG.tunnelRadius - CONFIG.ballRadius - 0.05;
                
                if (distanceFromCenter < minDistanceFromCenter) {
                    const pushDirection = ballToCenter.normalize().scale(-1);
                    const pushAmount = minDistanceFromCenter - distanceFromCenter;
                    ballWorldPos.addInPlace(pushDirection.scale(pushAmount));
                    
                    const correctedOffset = ballWorldPos.add(tunnelDir.scale(CONFIG.ballXOffset)).subtract(tunnelCenter);
                    const correctedLocal = new BABYLON.Vector3(
                        BABYLON.Vector3.Dot(correctedOffset, right),
                        BABYLON.Vector3.Dot(correctedOffset, up),
                        0
                    );
                    gameState.radialPosition = correctedLocal.length();
                    
                    if (gameState.radialPosition >= surfaceRadius - 0.2) {
                        gameState.isGrounded = true;
                        gameState.radialVelocity = 0;
                    }
                }
                
                if (distanceFromCenter > maxDistanceFromCenter) {
                    const pullDirection = ballToCenter.normalize();
                    const pullAmount = distanceFromCenter - maxDistanceFromCenter;
                    ballWorldPos.addInPlace(pullDirection.scale(pullAmount));
                    
                    gameState.radialPosition = maxDistanceFromCenter;
                    gameState.isGrounded = true;
                    gameState.radialVelocity = 0;
                }
                
                ball.position = ballWorldPos;
                
                const forwardRollSpeed = gameState.speed * 0.2 * dt;
                gameState.ballRotationX += forwardRollSpeed;
                
                const sideRollSpeed = gameState.angularVelocity * gameState.radialPosition * 0.5 * dt;
                gameState.ballRotationZ -= sideRollSpeed;
                
                const surfaceNormal = right.scale(Math.sin(gameState.theta))
                    .add(up.scale(Math.cos(gameState.theta))).normalize();
                
                const ballForward = tunnelDir.clone();
                const ballRight = BABYLON.Vector3.Cross(surfaceNormal, ballForward).normalize();
                const ballUp = surfaceNormal;
                
                const rotMatrix = BABYLON.Matrix.Identity();
                rotMatrix.setRowFromFloats(0, ballRight.x, ballRight.y, ballRight.z, 0);
                rotMatrix.setRowFromFloats(1, ballUp.x, ballUp.y, ballUp.z, 0);
                rotMatrix.setRowFromFloats(2, ballForward.x, ballForward.y, ballForward.z, 0);
                
                const baseRotation = BABYLON.Quaternion.FromRotationMatrix(rotMatrix);
                
                const rollRotation = BABYLON.Quaternion.RotationYawPitchRoll(
                    0,
                    gameState.ballRotationX,
                    gameState.ballRotationZ
                );
                
                ball.rotationQuaternion = baseRotation.multiply(rollRotation);
                
                updateTrailParticles(tunnelDir, gameState.speed);
                
                const cameraDistance = CONFIG.ballXOffset;
                const cameraHeight = 2.5;
                const cameraSideOffset = Math.sin(gameState.theta) * 2.5;
                
                const targetCameraPos = tunnelCenter
                    .subtract(tunnelDir.scale(cameraDistance))
                    .add(up.scale(cameraHeight + Math.cos(gameState.theta) * 1.5))
                    .add(right.scale(cameraSideOffset * 0.5));
                
                const lookAheadData = getSmoothPathData(gameState.distance + CONFIG.cameraLookAheadDistance);
                const targetLookAt = lookAheadData ? lookAheadData.position : ballWorldPos.add(tunnelDir.scale(CONFIG.cameraLookAheadDistance));
                
                if (!gameState.smoothedCameraPos) {
                    gameState.smoothedCameraPos = targetCameraPos.clone();
                    gameState.smoothedCameraTarget = targetLookAt.clone();
                    gameState.smoothedUp = up.clone();
                }
                
                const posSmoothing = CONFIG.cameraPositionSmoothing * dt;
                gameState.smoothedCameraPos = BABYLON.Vector3.Lerp(
                    gameState.smoothedCameraPos, 
                    targetCameraPos, 
                    Math.min(posSmoothing, 1)
                );
                
                const targetSmoothing = CONFIG.cameraTargetSmoothing * dt;
                gameState.smoothedCameraTarget = BABYLON.Vector3.Lerp(
                    gameState.smoothedCameraTarget, 
                    targetLookAt, 
                    Math.min(targetSmoothing, 1)
                );
                
                gameState.smoothedUp = BABYLON.Vector3.Lerp(
                    gameState.smoothedUp,
                    up,
                    Math.min(0.02 * dt, 1)
                ).normalize();
                
                camera.position = gameState.smoothedCameraPos;
                camera.setTarget(gameState.smoothedCameraTarget);
                camera.upVector = gameState.smoothedUp;
                
                const pointLight = scene.getLightByName('pointLight');
                if (pointLight) {
                    const lightTarget = tunnelCenter.add(tunnelDir.scale(25));
                    pointLight.position = BABYLON.Vector3.Lerp(pointLight.position, lightTarget, 0.05);
                }
                
                const ballLight = scene.getLightByName('ballLight');
                if (ballLight) {
                    ballLight.position = ballWorldPos;
                    // Make ball light white during invincibility (and not winding down)
                    if (gameState.isInvincible && !gameState.invincibilityWindingDown) {
                        ballLight.diffuse = new BABYLON.Color3(1, 1, 1);
                        ballLight.intensity = 3.0;
                    } else {
                        ballLight.diffuse = new BABYLON.Color3(0.3, 1, 0.5);
                        ballLight.intensity = 2.0;
                    }
                }
                
                const trailLight = scene.getLightByName('trailLight');
                if (trailLight) {
                    trailLight.position = ballWorldPos.add(tunnelDir.scale(1.5));
                }
                
                const rearLight = scene.getLightByName('rearLight');
                if (rearLight) {
                    const rearTarget = tunnelCenter.subtract(tunnelDir.scale(15));
                    rearLight.position = BABYLON.Vector3.Lerp(rearLight.position, rearTarget, 0.05);
                }
                
                if (segmentIndex > gameState.currentSegmentIndex) {
                    const deletionThreshold = segmentIndex - CONFIG.tunnelSegmentsBehind - CONFIG.tunnelSegmentsDeletionBuffer;
                    
                    while (tunnelSegments.length > 0 && tunnelSegments[0].index < deletionThreshold) {
                        removeTunnelSegment(tunnelSegments.shift());
                    }
                    
                    const neededIndex = segmentIndex + CONFIG.tunnelSegmentsAhead - 1;
                    createTunnelSegment(neededIndex);
                    
                    gameState.currentSegmentIndex = segmentIndex;
                }
                
                checkCollisions(ballWorldPos, tunnelCenter, right, up, segmentT);
            }
            
            updateUI();
        }

        function checkCollisions(ballPos, tunnelCenter, right, up, segmentT) {
            // Check collision with power-up gem first
            if (powerUpGem && !powerUpGem.isDisposed()) {
                const gemDistance = BABYLON.Vector3.Distance(ballPos, powerUpGem.position);
                const gemCollisionDist = CONFIG.ballRadius + 1.5;
                
                if (gemDistance < gemCollisionDist) {
                    // Collect the gem!
                    triggerGemExplosion(powerUpGem.position.clone());
                    destroyPowerUpGem();
                    activateInvincibility();
                    return;
                }
            }
            
            // Check collision with obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                if (!obstacle || obstacle.isDisposed()) continue;
                
                const obsPos = obstacle.position;
                const distance = BABYLON.Vector3.Distance(ballPos, obsPos);
                
                const collisionDist = CONFIG.ballRadius + (obstacle.cubeSize || 1.2) * 0.5;
                
                if (distance < collisionDist) {
                    if (gameState.isInvincible) {
                        // Destroy the cube!
                        destroyCube(obstacle, i);
                    } else {
                        // Game over
                        triggerExplosion(ballPos);
                        return;
                    }
                }
            }
        }
        
        function destroyCube(cube, index) {
            if (!cube || cube.isDisposed()) return;
            
            // Get cube color for explosion
            const cubeColor = cube.material ? cube.material.diffuseColor : new BABYLON.Color3(1, 0, 0);
            
            // Trigger cube explosion
            triggerCubeExplosion(cube.position.clone(), cubeColor);
            
            // Remove from glow layer
            glowLayer.removeIncludedOnlyMesh(cube);
            
            // Remove from obstacles array
            obstacles.splice(index, 1);
            
            // Also remove from segment obstacles
            for (const segment of tunnelSegments) {
                const obsIndex = segment.obstacles.indexOf(cube);
                if (obsIndex > -1) {
                    segment.obstacles.splice(obsIndex, 1);
                    const meshIndex = segment.meshes.indexOf(cube);
                    if (meshIndex > -1) {
                        segment.meshes.splice(meshIndex, 1);
                    }
                    break;
                }
            }
            
            // Dispose the cube
            cube.dispose();
            
            // Increment destroyed count
            gameState.cubesDestroyed++;
            
            // Boost speed (only if not winding down)
            if (!gameState.invincibilityWindingDown) {
                boostSpeed();
            }
            
            // Update UI
            if (destroyedCountElement) {
                destroyedCountElement.textContent = gameState.cubesDestroyed;
            }
            
            console.log('üí• Cube destroyed! Total:', gameState.cubesDestroyed);
        }

        function triggerExplosion(position) {
            gameState.isGameOver = true;
            
            stopTrailParticles();
            stopInvincibilityEffects();
            setTrailParticlesToNormal();  // NEW: Ensure trails are reset
            resetCubeColors();            // NEW: Reset cube colors
            
            // Hide power-up UI
            powerUpGaugeElement.classList.remove('active');
            cubesDestroyedElement.classList.remove('active');
            
            ball.visibility = 0;
            if (ballDecal) {
                ballDecal.visibility = 0;
            }
            glowLayer.removeIncludedOnlyMesh(ball);
            
            explosionParticles.emitter = position.clone();
            explosionParticles.manualEmitCount = CONFIG.explosionParticles;
            
            const originalClear = scene.clearColor.clone();
            scene.clearColor = new BABYLON.Color4(1, 0.3, 0, 1);
            setTimeout(() => {
                scene.clearColor = originalClear;
            }, 100);
            
            const originalPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 50;
                if (shakeTime > 500) {
                    clearInterval(shakeInterval);
                    return;
                }
                const intensity = (500 - shakeTime) / 500;
                camera.position.x = originalPos.x + (Math.random() - 0.5) * intensity * 2;
                camera.position.y = originalPos.y + (Math.random() - 0.5) * intensity * 2;
            }, 50);
            
            setTimeout(() => {
                checkAndShowHighScore();
            }, 1500);
        }

        function updateUI() {
            distanceElement.textContent = Math.floor(gameState.distance);
            bestDistanceElement.textContent = gameState.highScore;
        }
        
        function checkAndShowHighScore() {
            const currentDistance = Math.floor(gameState.distance);
            
            if (currentDistance > gameState.highScore) {
                const previousBest = gameState.highScore;
                gameState.highScore = currentDistance;
                saveHighScore();
                showHighScoreCelebration(currentDistance, previousBest);
            } else {
                showGameOver();
            }
        }
        
        function showHighScoreCelebration(newScore, previousBest) {
            celebrationDistanceElement.textContent = newScore;
            previousBestElement.textContent = previousBest;
            highScoreCelebration.style.display = 'block';
            createConfetti();
        }
        
        function createConfetti() {
            const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ff9ff3'];
            const celebrationElement = document.getElementById('highScoreCelebration');
            
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = (Math.random() * 10 + 5) + 'px';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                confetti.style.animation = `confettiFall ${Math.random() * 2 + 2}s linear forwards`;
                confetti.style.animationDelay = Math.random() * 1 + 's';
                celebrationElement.appendChild(confetti);
                
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, 4000);
            }
        }
        
        function continueToProceed() {
            highScoreCelebration.style.display = 'none';
            showGameOver();
        }

        function showGameOver() {
            finalDistanceElement.textContent = Math.floor(gameState.distance);
            gameOverBestElement.textContent = gameState.highScore;
            bestDistanceElement.textContent = gameState.highScore;
            gameOverElement.style.display = 'block';
        }

        async function startGame() {
            startScreen.style.display = 'none';
            
            requestFullscreen();
            
            if (isMobile) {
                await requestAccelerometerPermission();
            }
            
            resetGame();
            gameState.isRunning = true;
            
            if (!instructionsShownThisSession) {
                const desktopInstructions = document.querySelector('#instructions.desktop-only');
                const mobileInstructions = document.querySelector('#instructions.mobile-only');
                
                if (isMobile && mobileInstructions) {
                    mobileInstructions.style.display = 'block';
                    mobileInstructions.style.opacity = '0.7';
                } else if (!isMobile && desktopInstructions) {
                    desktopInstructions.style.display = 'block';
                    desktopInstructions.style.opacity = '0.7';
                }
            }
        }

        function restartGame() {
            gameOverElement.style.display = 'none';
            
            requestFullscreen();
            
            resetGame();
            gameState.isRunning = true;
            
            if (instructionsShownThisSession) {
                const desktopInstructions = document.querySelector('#instructions.desktop-only');
                const mobileInstructions = document.querySelector('#instructions.mobile-only');
                if (desktopInstructions) desktopInstructions.style.display = 'none';
                if (mobileInstructions) mobileInstructions.style.display = 'none';
            }
        }

        function resetGame() {
            keys.left = false;
            keys.right = false;
            keys.jump = false;
            
            gameState.isGameOver = false;
            gameState.isPaused = false;
            gameState.distance = 0;
            gameState.speed = CONFIG.baseSpeed;
            gameState.theta = Math.PI;
            gameState.angularVelocity = 0;
            gameState.radialPosition = CONFIG.tunnelRadius - CONFIG.ballRadius;
            gameState.radialVelocity = 0;
            gameState.isGrounded = true;
            gameState.ballRotationX = 0;
            gameState.ballRotationZ = 0;
            gameState.currentSegmentIndex = 0;
            gameState.currentTunnelDir = new BABYLON.Vector3(0, 0, 1);
            
            gameState.smoothedCameraPos = null;
            gameState.smoothedCameraTarget = null;
            gameState.smoothedUp = null;
            
            gameState.gameplayTime = 0;
            gameState.instructionsDismissed = false;
            
            // Reset power-up state
            gameState.isInvincible = false;
            gameState.invincibilityTimeRemaining = 0;
            gameState.invincibilityWindingDown = false;
            gameState.nextGemDistance = CONFIG.powerUpMinDistance + Math.random() * (CONFIG.powerUpMaxDistance - CONFIG.powerUpMinDistance);
            gameState.cubesDestroyed = 0;
            gameState.currentMaxSpeed = CONFIG.maxSpeed;
            gameState.speedBoostTimer = 0;
            gameState.isDecelerating = false;
            gameState.preBoostSpeed = CONFIG.baseSpeed;
            gameState.powerUpFlashTime = 0;  // NEW: Reset flash timer
            
            // Clean up power-up gem if exists
            destroyPowerUpGem();
            
            // Hide power-up UI
            powerUpGaugeElement.classList.remove('active');
            cubesDestroyedElement.classList.remove('active');
            
            // Stop invincibility effects
            stopInvincibilityEffects();
            
            // NEW: Ensure trail particles are normal colors
            setTrailParticlesToNormal();
            
            initializeObstacleColor();
            
            const tiltIndicator = document.getElementById('tiltIndicator');
            if (tiltIndicator && isMobile) {
                tiltIndicator.style.opacity = '1';
                tiltIndicator.style.transition = '';
            }
            
            tunnelSegments.forEach(seg => removeTunnelSegment(seg));
            tunnelSegments = [];
            obstacles = [];
            
            initializeTunnelPath();
            
            for (let i = -CONFIG.tunnelSegmentsBehind; i < CONFIG.tunnelSegmentsAhead; i++) {
                createTunnelSegment(i);
            }
            
            startTrailParticles();
            
            ball.visibility = 1;
            if (ballDecal) {
                ballDecal.visibility = 1;
            }
            ball.rotationQuaternion = BABYLON.Quaternion.Identity();
            glowLayer.addIncludedOnlyMesh(ball);
            
            // Reset ball material
            if (ballMaterial) {
                ballMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.9, 0.4);
                ballMaterial.emissiveColor = new BABYLON.Color3(0.08, 0.5, 0.25);
            }
            
            camera.position = new BABYLON.Vector3(0, 3, -CONFIG.ballXOffset);
            camera.setTarget(new BABYLON.Vector3(0, 0, 10));
            camera.upVector = BABYLON.Vector3.Up();
            
            updateUI();
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
